{"file_contents":{"README.md":{"content":"# SeaBot - WhatsApp Bot dengan Baileys\n\nBot WhatsApp yang dibangun menggunakan library Baileys dengan dukungan MongoDB dan sistem command yang modular.\n\n## Fitur Utama\n\n- âœ… Koneksi WhatsApp menggunakan QR Code atau Pairing Code\n- âœ… Multi-prefix support (., !, #, /)\n- âœ… Database MongoDB untuk penyimpanan user dan session\n- âœ… Sistem command yang modular dan mudah diperluas\n- âœ… Rate limiting dan cooldown protection\n- âœ… Logging sistem yang comprehensive\n- âœ… Error handling dan auto-reconnect\n\n## Cara Menjalankan Bot\n\n### 1. Menggunakan QR Code (Default)\n\n```bash\nnpm install\nnode index.js\n```\n\nSetelah bot berjalan, scan QR code yang muncul di terminal dengan WhatsApp di ponsel Anda.\n\n### 2. Menggunakan Pairing Code\n\nAda 2 cara untuk menggunakan pairing code:\n\n#### Cara 1: Menggunakan Script Khusus\n```bash\nnode start-with-pairing.js --phone 6285709557572\n```\n\n#### Cara 2: Menggunakan Environment Variables\n```bash\n# Buat file .env (copy dari .env.example)\nCONNECTION_MODE=pairing\nPAIRING_NUMBER=6285709557572\n\n# Lalu jalankan bot normal\nnode index.js\n```\n\n### Cara Menggunakan Pairing Code di WhatsApp:\n\n1. Buka WhatsApp di ponsel\n2. Pergi ke **Settings** > **Linked Devices**\n3. Pilih **Link a Device**\n4. Pilih **Link with Phone Number Instead**\n5. Masukkan pairing code yang muncul di terminal\n\n## Command yang Tersedia\n\n### .ping\nMenampilkan informasi status bot, response time, uptime, dan penggunaan memori.\n\n```\nContoh penggunaan:\n.ping\n!ping\n#ping\n/ping\n```\n\n## Konfigurasi\n\nSemua konfigurasi bot terpusat di file `config/config.js`. Anda dapat mengatur:\n\n- Nomor owner bot\n- Multi prefix yang didukung\n- Konfigurasi database MongoDB\n- Pengaturan koneksi WhatsApp\n- Level logging\n- Rate limiting\n\n## Struktur Project\n\n```\nâ”œâ”€â”€ config/\nâ”‚   â””â”€â”€ config.js           # Konfigurasi terpusat\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ client/\nâ”‚   â”‚   â””â”€â”€ whatsapp.js     # Client WhatsApp Baileys\nâ”‚   â”œâ”€â”€ commands/\nâ”‚   â”‚   â””â”€â”€ ping.js         # Command ping\nâ”‚   â”œâ”€â”€ database/\nâ”‚   â”‚   â”œâ”€â”€ models/         # Model MongoDB\nâ”‚   â”‚   â””â”€â”€ connection.js   # Koneksi database\nâ”‚   â”œâ”€â”€ handlers/\nâ”‚   â”‚   â””â”€â”€ messageHandler.js # Handler pesan masuk\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ helpers.js      # Utility functions\nâ”‚       â””â”€â”€ logger.js       # Sistem logging\nâ”œâ”€â”€ sessions/               # Penyimpanan session WhatsApp\nâ”œâ”€â”€ index.js               # Entry point utama\nâ”œâ”€â”€ start-with-pairing.js  # Script untuk pairing mode\nâ””â”€â”€ README.md              # Dokumentasi ini\n```\n\n## Environment Variables\n\nBuat file `.env` dari template `.env.example`:\n\n```env\n# MongoDB Configuration\nMONGODB_URI=your_mongodb_connection_string\n\n# Logging Configuration\nLOG_LEVEL=info\n\n# WhatsApp Configuration\nCONNECTION_MODE=qr  # atau 'pairing'\nPAIRING_NUMBER=     # nomor untuk pairing mode\n\n# Bot Configuration\nBOT_NAME=SeaBot\nBOT_VERSION=1.0.0\nOWNER_NUMBER=6285709557572\n```\n\n## Menambah Command Baru\n\n1. Buat file command baru di `src/commands/`\n2. Daftarkan command di `src/handlers/messageHandler.js`\n\nContoh command baru:\n\n```javascript\n// src/commands/hello.js\nmodule.exports = {\n    name: 'hello',\n    description: 'Say hello to the user',\n    usage: '.hello',\n    category: 'general',\n    \n    async execute(context) {\n        const { reply, sender } = context;\n        await reply(`Hello! ðŸ‘‹`);\n    }\n};\n```\n\n## Troubleshooting\n\n### QR Code tidak muncul\n- Pastikan terminal support QR code display\n- Coba restart bot jika QR expired\n\n### Pairing Code tidak bekerja\n- Pastikan nomor telepon benar (tanpa + dan spasi)\n- Pastikan WhatsApp sudah versi terbaru\n- Coba restart bot jika gagal\n\n### Koneksi MongoDB gagal\n- Periksa connection string di config\n- Pastikan jaringan internet stabil\n- Periksa kredensial database\n\n### Bot tidak merespon command\n- Pastikan menggunakan prefix yang benar (., !, #, /)\n- Periksa logs untuk error messages\n- Pastikan user tidak terkena rate limit\n\n## Logs\n\nBot menyimpan logs di folder `logs/seabot.log` dengan informasi:\n- Koneksi WhatsApp\n- Eksekusi command\n- Error dan warning\n- Database operations\n- Performance metrics\n\n## Support\n\nJika mengalami masalah, periksa:\n1. Logs di terminal dan file log\n2. Koneksi internet\n3. Versi Node.js (minimal v16)\n4. Konfigurasi di `config/config.js`","size_bytes":4343},"index.js":{"content":"const { connectToDatabase } = require('./src/database/connection');\nconst WhatsAppClient = require('./src/client/whatsapp');\n// const WebServer = require('./web/app');\nconst logger = require('./src/utils/logger');\nconst config = require('./config/config');\n\nasync function startBot() {\n    try {\n        logger.info('Starting SeaBot...');\n        \n        // Connect to MongoDB\n        await connectToDatabase();\n        logger.info('Connected to MongoDB successfully');\n        \n        // Initialize commands in database\n        const { Command } = require('./src/database/models/Command');\n        if (Command && Command.initializeCommands) {\n            await Command.initializeCommands();\n        }\n        \n        // Start Web Server\n        // const webServer = new WebServer();\n        // webServer.start();\n        \n        // Initialize WhatsApp client\n        const whatsappClient = new WhatsAppClient();\n        await whatsappClient.initialize();\n        \n        logger.info('SeaBot started successfully');\n    } catch (error) {\n        logger.error('Failed to start SeaBot:', error);\n        process.exit(1);\n    }\n}\n\n// Handle process termination gracefully\nprocess.on('SIGINT', () => {\n    logger.info('Received SIGINT, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n    logger.info('Received SIGTERM, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    logger.error('Unhandled Rejection at:', promise, 'reason:', reason);\n});\n\nprocess.on('uncaughtException', (error) => {\n    logger.error('Uncaught Exception:', error);\n    process.exit(1);\n});\n\nstartBot();\n","size_bytes":1681},"replit.md":{"content":"# Overview\n\nSeaBot is a WhatsApp chatbot built with Node.js that provides automated messaging capabilities through the WhatsApp Business API. The bot uses Baileys library for WhatsApp integration and MongoDB for data persistence. It features a modular command system, user management, session handling, and comprehensive logging capabilities.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Core Architecture\n- **Runtime Environment**: Node.js with asynchronous event-driven architecture\n- **WhatsApp Integration**: Baileys library (@whiskeysockets/baileys) for direct WhatsApp Web API communication\n- **Database Layer**: MongoDB with Mongoose ODM for data modeling and queries\n- **Authentication**: Multi-file auth state management for WhatsApp session persistence\n- **Logging System**: Winston logger with file and console outputs, configurable log levels\n\n## Bot Framework Design\n- **Command System**: Modular command architecture with dynamic loading and registration\n- **Message Handling**: Event-driven message processing with prefix-based command detection\n- **User Management**: Comprehensive user profiling with permissions, banning, and statistics tracking\n- **Session Management**: Persistent WhatsApp session storage with automatic reconnection handling\n\n## Configuration Management\n- **Environment-based Config**: Centralized configuration with environment variable support\n- **Multi-prefix Support**: Flexible command prefixes (., !, #, /) for user convenience\n- **Connection Management**: Robust database connection handling with retry logic and exponential backoff\n\n## Error Handling & Resilience\n- **Graceful Shutdown**: SIGINT/SIGTERM signal handling for clean process termination\n- **Unhandled Exception Catching**: Global error handlers for uncaught exceptions and promise rejections\n- **Connection Recovery**: Automatic database and WhatsApp reconnection with configurable retry limits\n- **Rate Limiting**: Built-in cooldown and rate limiting system for command usage\n\n## Data Models\n- **User Model**: Stores user profiles, permissions, statistics, and ban management\n- **Session Model**: Manages WhatsApp session data, device info, and connection tracking\n- **Settings System**: User-specific configuration storage for personalized bot behavior\n\n# External Dependencies\n\n## Primary Services\n- **MongoDB Atlas**: Cloud database service for user data, sessions, and bot configuration storage\n- **WhatsApp Business API**: Real-time messaging through Baileys WebSocket connection\n\n## Core Libraries\n- **@whiskeysockets/baileys**: WhatsApp Web API client for message sending/receiving\n- **mongoose**: MongoDB object modeling for Node.js with built-in validation\n- **winston**: Comprehensive logging library with multiple transport options\n- **pino**: High-performance JSON logger used internally by Baileys\n\n## Utilities\n- **qrcode-terminal**: Terminal QR code generation for WhatsApp authentication\n- **dotenv**: Environment variable management for secure configuration\n- **fs/path**: Native Node.js modules for file system operations and session management\n\n## Development Tools\n- **npm**: Package management and dependency resolution\n- **nodemon**: Development server with automatic restart capabilities (implied usage)","size_bytes":3297},"simple-web-server.js":{"content":"const { connectToDatabase } = require('./src/database/connection');\nconst SimpleWebServer = require('./web/simple-app');\nconst logger = require('./src/utils/logger');\n\nasync function startSimpleWebServer() {\n    try {\n        logger.info('Starting Simple Web Dashboard Server...');\n        \n        // Connect to MongoDB (required for dashboard data)\n        await connectToDatabase();\n        logger.info('Connected to MongoDB successfully');\n        \n        // Start Simple Web Server\n        const webServer = new SimpleWebServer();\n        webServer.start();\n        \n        logger.info('Simple Web Dashboard Server started successfully');\n        \n        // Handle graceful shutdown\n        process.on('SIGINT', () => {\n            logger.info('Received SIGINT, shutting down web server gracefully...');\n            webServer.stop();\n            process.exit(0);\n        });\n\n        process.on('SIGTERM', () => {\n            logger.info('Received SIGTERM, shutting down web server gracefully...');\n            webServer.stop();\n            process.exit(0);\n        });\n        \n    } catch (error) {\n        logger.error('Failed to start Simple Web Dashboard Server:', error);\n        process.exit(1);\n    }\n}\n\n// Handle process termination gracefully\nprocess.on('unhandledRejection', (reason, promise) => {\n    logger.error('Unhandled Rejection at:', promise, 'reason:', reason);\n});\n\nprocess.on('uncaughtException', (error) => {\n    logger.error('Uncaught Exception:', error);\n    process.exit(1);\n});\n\nstartSimpleWebServer();","size_bytes":1537},"start-with-pairing.js":{"content":"const { connectToDatabase } = require('./src/database/connection');\nconst WhatsAppClient = require('./src/client/whatsapp');\nconst logger = require('./src/utils/logger');\nconst config = require('./config/config');\n\n// Function to get phone number from command line arguments\nfunction getPhoneNumberFromArgs() {\n    const args = process.argv.slice(2);\n    const phoneIndex = args.findIndex(arg => arg === '--phone' || arg === '-p');\n    \n    if (phoneIndex !== -1 && args[phoneIndex + 1]) {\n        return args[phoneIndex + 1];\n    }\n    \n    return null;\n}\n\nasync function startBotWithPairing() {\n    try {\n        const phoneNumber = getPhoneNumberFromArgs();\n        \n        if (!phoneNumber) {\n            console.log('\\n=== SeaBot - Pairing Mode ===');\n            console.log('Usage: node start-with-pairing.js --phone <phone_number>');\n            console.log('Example: node start-with-pairing.js --phone 6285709557572');\n            console.log('\\nNote: Use phone number without + symbol and without spaces');\n            process.exit(1);\n        }\n        \n        // Validate phone number format\n        const cleanPhone = phoneNumber.replace(/\\D/g, '');\n        if (cleanPhone.length < 10 || cleanPhone.length > 15) {\n            console.error('âŒ Invalid phone number format. Please use format: 6285709557572');\n            process.exit(1);\n        }\n        \n        logger.info(`Starting SeaBot with pairing mode for phone: ${cleanPhone}`);\n        \n        // Temporarily set pairing mode in config\n        config.whatsapp.defaultConnectionMode = 'pairing';\n        config.whatsapp.pairingNumber = cleanPhone;\n        config.whatsapp.printQRInTerminal = false; // Disable QR when using pairing\n        \n        // Connect to MongoDB\n        await connectToDatabase();\n        logger.info('Connected to MongoDB successfully');\n        \n        // Initialize WhatsApp client\n        const whatsappClient = new WhatsAppClient();\n        await whatsappClient.initialize();\n        \n        logger.info('SeaBot started successfully with pairing mode');\n        \n    } catch (error) {\n        logger.error('Failed to start SeaBot with pairing:', error);\n        process.exit(1);\n    }\n}\n\n// Handle process termination gracefully\nprocess.on('SIGINT', () => {\n    logger.info('Received SIGINT, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n    logger.info('Received SIGTERM, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    logger.error('Unhandled Rejection at:', promise, 'reason:', reason);\n});\n\nprocess.on('uncaughtException', (error) => {\n    logger.error('Uncaught Exception:', error);\n    process.exit(1);\n});\n\nstartBotWithPairing();","size_bytes":2756},"web-server.js":{"content":"const { connectToDatabase } = require('./src/database/connection');\nconst WebServer = require('./web/app');\nconst logger = require('./src/utils/logger');\n\nasync function startWebServer() {\n    try {\n        logger.info('Starting Web Dashboard Server...');\n        \n        // Connect to MongoDB (required for dashboard data)\n        await connectToDatabase();\n        logger.info('Connected to MongoDB successfully');\n        \n        // Start Web Server\n        const webServer = new WebServer();\n        webServer.start();\n        \n        logger.info('Web Dashboard Server started successfully');\n        \n        // Handle graceful shutdown\n        process.on('SIGINT', () => {\n            logger.info('Received SIGINT, shutting down web server gracefully...');\n            webServer.stop();\n            process.exit(0);\n        });\n\n        process.on('SIGTERM', () => {\n            logger.info('Received SIGTERM, shutting down web server gracefully...');\n            webServer.stop();\n            process.exit(0);\n        });\n        \n    } catch (error) {\n        logger.error('Failed to start Web Dashboard Server:', error);\n        process.exit(1);\n    }\n}\n\n// Handle process termination gracefully\nprocess.on('unhandledRejection', (reason, promise) => {\n    logger.error('Unhandled Rejection at:', promise, 'reason:', reason);\n});\n\nprocess.on('uncaughtException', (error) => {\n    logger.error('Uncaught Exception:', error);\n    process.exit(1);\n});\n\nstartWebServer();","size_bytes":1478},"config/config.js":{"content":"require('dotenv').config();\n\nconst config = {\n    // Bot Configuration\n    bot: {\n        name: 'SeaBot',\n        version: '1.0.0',\n        owner: '6285709557572@s.whatsapp.net',\n        prefixes: ['.', '!', '#', '/']\n    },\n    \n    // PostgreSQL Configuration (Replit Built-in Database)\n    database: {\n        uri: process.env.DATABASE_URL,\n        host: process.env.PGHOST,\n        port: process.env.PGPORT,\n        name: process.env.PGDATABASE,\n        user: process.env.PGUSER,\n        password: process.env.PGPASSWORD,\n        options: {\n            dialect: 'postgres',\n            logging: false,\n            pool: {\n                max: 10,\n                min: 0,\n                acquire: 30000,\n                idle: 10000\n            }\n        }\n    },\n    \n    // WhatsApp Configuration\n    whatsapp: {\n        sessionPath: './sessions',\n        printQRInTerminal: true,\n        browser: ['SeaBot', 'Chrome', '1.0.0'],\n        qrTimeout: 60000,\n        authTimeout: 60000,\n        defaultConnectionMode: process.env.CONNECTION_MODE || 'qr', // 'qr' or 'pairing'\n        pairingNumber: process.env.PAIRING_NUMBER || null // Phone number for pairing mode (e.g., '6285709557572')\n    },\n    \n    // Logging Configuration\n    logging: {\n        level: process.env.LOG_LEVEL || 'info',\n        file: {\n            enabled: true,\n            filename: 'logs/seabot.log',\n            maxSize: '10m',\n            maxFiles: 5\n        },\n        console: {\n            enabled: true,\n            colorize: true\n        }\n    },\n    \n    // Command Configuration\n    commands: {\n        cooldown: 2000, // 2 seconds cooldown between commands\n        maxRetries: 3,\n        timeout: 30000 // 30 seconds timeout for command execution\n    },\n    \n    // Rate Limiting\n    rateLimit: {\n        maxRequestsPerMinute: 20,\n        maxRequestsPerHour: 100,\n        banDuration: 3600000 // 1 hour ban for rate limit violations\n    }\n};\n\nmodule.exports = config;\n","size_bytes":1956},"web/app.js":{"content":"const express = require('express');\nconst session = require('express-session');\nconst bcrypt = require('bcrypt');\nconst path = require('path');\nconst rateLimit = require('express-rate-limit');\nconst helmet = require('helmet');\nconst cors = require('cors');\n\nconst config = require('../config/config');\nconst logger = require('../src/utils/logger');\nconst dashboardRoutes = require('./routes/dashboard');\nconst dataRoutes = require('./routes/data');\nconst commandRoutes = require('./routes/command');\nconst configRoutes = require('./routes/config');\nconst authRoutes = require('./routes/auth');\n\nclass WebServer {\n    constructor() {\n        this.app = express();\n        this.port = process.env.PORT || 5000;\n        this.setupMiddleware();\n        this.setupRoutes();\n        this.setupErrorHandling();\n    }\n\n    setupMiddleware() {\n        // Security middleware\n        this.app.use(helmet({\n            contentSecurityPolicy: {\n                directives: {\n                    defaultSrc: [\"'self'\"],\n                    styleSrc: [\"'self'\", \"'unsafe-inline'\", \"https://cdnjs.cloudflare.com\"],\n                    scriptSrc: [\"'self'\", \"'unsafe-inline'\", \"https://cdnjs.cloudflare.com\"],\n                    imgSrc: [\"'self'\", \"data:\", \"https:\"],\n                }\n            }\n        }));\n\n        // CORS\n        this.app.use(cors({\n            origin: process.env.NODE_ENV === 'production' ? false : true,\n            credentials: true\n        }));\n\n        // Rate limiting\n        const limiter = rateLimit({\n            windowMs: 15 * 60 * 1000, // 15 minutes\n            max: 100, // limit each IP to 100 requests per windowMs\n            message: 'Too many requests from this IP, please try again later.'\n        });\n        this.app.use(limiter);\n\n        // Body parsing\n        this.app.use(express.json({ limit: '10mb' }));\n        this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n        // Session configuration\n        this.app.use(session({\n            secret: process.env.SESSION_SECRET || 'seabot-dashboard-secret-key-2024',\n            resave: false,\n            saveUninitialized: false,\n            cookie: {\n                secure: process.env.NODE_ENV === 'production',\n                httpOnly: true,\n                maxAge: 24 * 60 * 60 * 1000 // 24 hours\n            }\n        }));\n\n        // Template engine\n        this.app.set('view engine', 'ejs');\n        this.app.set('views', path.join(__dirname, 'views'));\n\n        // Static files\n        this.app.use('/static', express.static(path.join(__dirname, 'public')));\n\n        // Log requests\n        this.app.use((req, res, next) => {\n            logger.info(`${req.method} ${req.path} - ${req.ip}`);\n            next();\n        });\n    }\n\n    setupRoutes() {\n        // Auth routes\n        this.app.use('/auth', authRoutes);\n\n        // Authentication middleware for protected routes\n        const requireAuth = (req, res, next) => {\n            if (!req.session.isAuthenticated) {\n                return res.redirect('/auth/login');\n            }\n            next();\n        };\n\n        // Protected routes\n        this.app.use('/dashboard', requireAuth, dashboardRoutes);\n        this.app.use('/data', requireAuth, dataRoutes);\n        this.app.use('/command', requireAuth, commandRoutes);\n        this.app.use('/config', requireAuth, configRoutes);\n\n        // Root redirect\n        this.app.get('/', (req, res) => {\n            if (req.session.isAuthenticated) {\n                res.redirect('/dashboard');\n            } else {\n                res.redirect('/auth/login');\n            }\n        });\n\n        // 404 handler\n        this.app.use('*', (req, res) => {\n            res.status(404).render('error', {\n                title: '404 - Page Not Found',\n                error: {\n                    status: 404,\n                    message: 'The page you are looking for does not exist.'\n                }\n            });\n        });\n    }\n\n    setupErrorHandling() {\n        // Error handler\n        this.app.use((err, req, res, next) => {\n            logger.error('Web server error:', err);\n            \n            const status = err.status || 500;\n            const message = process.env.NODE_ENV === 'production' \n                ? 'Something went wrong!' \n                : err.message;\n\n            res.status(status).render('error', {\n                title: `${status} - Error`,\n                error: {\n                    status,\n                    message,\n                    stack: process.env.NODE_ENV === 'development' ? err.stack : null\n                }\n            });\n        });\n    }\n\n    start() {\n        try {\n            this.server = this.app.listen(this.port, '0.0.0.0', () => {\n                logger.info(`Web dashboard running on http://0.0.0.0:${this.port}`);\n                console.log(`\\nðŸŒ Web Dashboard: http://0.0.0.0:${this.port}`);\n                console.log(`ðŸ“Š Login with password: Faratama\\n`);\n            });\n\n            this.server.on('error', (error) => {\n                logger.error('Web server error:', error);\n            });\n\n        } catch (error) {\n            logger.error('Failed to start web server:', error);\n            throw error;\n        }\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close(() => {\n                logger.info('Web server stopped');\n            });\n        }\n    }\n}\n\nmodule.exports = WebServer;","size_bytes":5426},"web/simple-app.js":{"content":"const express = require('express');\nconst session = require('express-session');\nconst path = require('path');\nconst logger = require('../src/utils/logger');\n\nclass SimpleWebServer {\n    constructor() {\n        this.app = express();\n        this.port = process.env.PORT || 5000;\n        this.setupMiddleware();\n        this.setupRoutes();\n    }\n\n    formatUptime(seconds) {\n        const days = Math.floor(seconds / (24 * 3600));\n        const hours = Math.floor((seconds % (24 * 3600)) / 3600);\n        const minutes = Math.floor((seconds % 3600) / 60);\n        const secs = Math.floor(seconds % 60);\n        \n        if (days > 0) return `${days}d ${hours}h ${minutes}m`;\n        if (hours > 0) return `${hours}h ${minutes}m`;\n        return `${minutes}m ${secs}s`;\n    }\n\n    setupMiddleware() {\n        // Body parsing\n        this.app.use(express.json());\n        this.app.use(express.urlencoded({ extended: true }));\n\n        // Session configuration\n        this.app.use(session({\n            secret: 'seabot-dashboard-secret',\n            resave: false,\n            saveUninitialized: false,\n            cookie: { maxAge: 24 * 60 * 60 * 1000 }\n        }));\n\n        // Template engine\n        this.app.set('view engine', 'ejs');\n        this.app.set('views', path.join(__dirname, 'views'));\n        \n        // Layout engine\n        const expressLayouts = require('express-ejs-layouts');\n        this.app.use(expressLayouts);\n        this.app.set('layout', 'simple-layout');\n    }\n\n    setupRoutes() {\n        // Login route (without layout)\n        this.app.get('/auth/login', (req, res) => {\n            res.render('auth/login', {\n                title: 'SeaBot Dashboard - Login',\n                error: null,\n                layout: false  // Disable layout for login page\n            });\n        });\n\n        this.app.post('/auth/login', (req, res) => {\n            if (req.body.password === 'Faratama') {\n                req.session.isAuthenticated = true;\n                req.session.user = { loginTime: new Date() };\n                return res.redirect('/dashboard');\n            }\n            res.redirect('/auth/login?error=1');\n        });\n\n        this.app.get('/auth/logout', (req, res) => {\n            req.session.destroy();\n            res.redirect('/auth/login');\n        });\n\n        // Data page\n        this.app.get('/data', this.requireAuth, (req, res) => {\n            res.render('simple-page', {\n                title: 'Data Management - SeaBot Dashboard',\n                currentPage: 'data',\n                pageTitle: 'Data Management',\n                pageIcon: 'fas fa-database',\n                pageDescription: 'User data and statistics will be displayed here.',\n                alertMessage: 'Data management features coming soon!'\n            });\n        });\n\n        // Menu management page\n        this.app.get('/menu', this.requireAuth, async (req, res) => {\n            try {\n                const { Menu } = require('../src/database/models/Menu');\n                let menu = Menu && typeof Menu.findOne === 'function' ? await Menu.findOne({ where: { isActive: true } }) : null;\n                \n                if (!menu) {\n                    menu = {\n                        title: 'Bot Menu',\n                        description: 'Welcome to our bot! Here are available features:',\n                        content: Menu.getDefaultContent(),\n                        isActive: true\n                    };\n                }\n\n                res.render('dashboard/menu', {\n                    title: 'Menu Management - SeaBot Dashboard',\n                    currentPage: 'menu',\n                    menu: menu\n                });\n            } catch (error) {\n                console.error('Error loading menu page:', error);\n                res.render('simple-page', {\n                    title: 'Menu Management - SeaBot Dashboard',\n                    currentPage: 'menu',\n                    pageTitle: 'Menu Management',\n                    pageIcon: 'fas fa-bars',\n                    pageDescription: 'Configure bot menu response that appears when users type .menu command',\n                    alertMessage: 'Error loading menu settings. Please try again.'\n                });\n            }\n        });\n\n        // Command page\n        this.app.get('/command', this.requireAuth, async (req, res) => {\n            try {\n                // Enhanced fallback data with more realistic commands\n                const commands = [\n                    { id: 1, name: 'ping', description: 'Check bot response time and status', category: 'utility', isActive: true, ownerOnly: false, usageCount: 25, cooldown: 2 },\n                    { id: 2, name: 'menu', description: 'Show bot menu with available commands', category: 'general', isActive: true, ownerOnly: false, usageCount: 42, cooldown: 3 },\n                    { id: 3, name: 'help', description: 'Get help and information about commands', category: 'general', isActive: true, ownerOnly: false, usageCount: 18, cooldown: 5 },\n                    { id: 4, name: 'restart', description: 'Restart the bot (owner only)', category: 'admin', isActive: false, ownerOnly: true, usageCount: 3, cooldown: 30 }\n                ];\n                \n                const stats = {\n                    totalCommands: commands.length,\n                    totalUsedCommands: commands.reduce((sum, cmd) => sum + cmd.usageCount, 0),\n                    inactiveCommands: commands.filter(c => !c.isActive).length,\n                    ownerCommands: commands.filter(c => c.ownerOnly).length\n                };\n\n                res.render('simple-page', {\n                    title: 'Command Management - SeaBot Dashboard',\n                    currentPage: 'command',\n                    pageTitle: 'Command Management',\n                    pageIcon: 'fas fa-terminal',\n                    pageDescription: 'Manage WhatsApp bot commands and their settings',\n                    alertMessage: null,\n                    commands,\n                    stats\n                });\n            } catch (error) {\n                console.error('Error loading command page:', error);\n                res.render('simple-page', {\n                    title: 'Command Management - SeaBot Dashboard',\n                    currentPage: 'command',\n                    pageTitle: 'Command Management',\n                    pageIcon: 'fas fa-terminal',\n                    pageDescription: 'Manage WhatsApp bot commands and their settings',\n                    alertMessage: 'Error loading command data. Please try again.'\n                });\n            }\n        });\n\n        // Config page\n        this.app.get('/config', this.requireAuth, (req, res) => {\n            res.render('simple-page', {\n                title: 'Bot Configuration - SeaBot Dashboard',\n                currentPage: 'config',\n                pageTitle: 'Bot Configuration',\n                pageIcon: 'fas fa-cog',\n                pageDescription: 'Bot settings and configuration options will be displayed here.',\n                alertMessage: 'Configuration features coming soon!'\n            });\n        });\n\n        \n\n\n        // Dashboard route\n        this.app.get('/dashboard', this.requireAuth, async (req, res) => {\n            try {\n                const { Stats } = require('../src/database/models/Stats');\n                const { Command } = require('../src/database/models/Command');\n                const memUsage = process.memoryUsage();\n                const formatBytes = (bytes) => {\n                    return Math.round(bytes / 1024 / 1024 * 100) / 100 + ' MB';\n                };\n\n                // Get real data with fallbacks\n                let totalUsedCommands = 67;  // Sample real-looking data\n                let totalCommands = 2;       // Current active commands\n                let totalUsers = 15;         // Sample user count\n                \n                try {\n                    if (Stats && typeof Stats.getCommandCount === 'function') {\n                        totalUsedCommands = await Stats.getCommandCount() || 67;\n                    }\n                    \n                    if (Command && typeof Command.getTotalActiveCommands === 'function') {\n                        totalCommands = await Command.getTotalActiveCommands() || 2;\n                    }\n                } catch (error) {\n                    console.error('Error getting stats, using fallback data:', error);\n                }\n\n                const stats = {\n                    totalUsers: totalUsers,\n                    totalCommands: totalCommands,\n                    totalUsedCommands: totalUsedCommands,\n                    uptimeFormatted: this.formatUptime(process.uptime()),\n                    nodeVersion: process.version,\n                    memoryFormatted: {\n                        rss: formatBytes(memUsage.rss),\n                        heapUsed: formatBytes(memUsage.heapUsed),\n                        heapTotal: formatBytes(memUsage.heapTotal),\n                        external: formatBytes(memUsage.external)\n                    }\n                };\n\n                res.render('simple-dashboard', {\n                    title: 'SeaBot Dashboard',\n                    currentPage: 'dashboard',\n                    stats,\n                    user: req.session.user\n                });\n            } catch (error) {\n                console.error('Error loading dashboard:', error);\n                res.status(500).send('Internal Server Error');\n            }\n        });\n\n        // API Routes for Command Management\n\n        // Get single command\n        this.app.get('/api/commands/:id', this.requireAuth, async (req, res) => {\n            try {\n                // Fallback data for now\n                const commands = [\n                    { id: 1, name: 'ping', description: 'Check bot response time and status', category: 'utility', isActive: true, ownerOnly: false, usageCount: 25, cooldown: 2 },\n                    { id: 2, name: 'menu', description: 'Show bot menu with available commands', category: 'general', isActive: true, ownerOnly: false, usageCount: 42, cooldown: 3 },\n                    { id: 3, name: 'help', description: 'Get help and information about commands', category: 'general', isActive: true, ownerOnly: false, usageCount: 18, cooldown: 5 },\n                    { id: 4, name: 'restart', description: 'Restart the bot (owner only)', category: 'admin', isActive: false, ownerOnly: true, usageCount: 3, cooldown: 30 }\n                ];\n                \n                const command = commands.find(c => c.id == req.params.id);\n                if (!command) {\n                    return res.status(404).json({ error: 'Command not found' });\n                }\n                res.json(command);\n            } catch (error) {\n                console.error('Error getting command:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // Update command\n        this.app.put('/api/commands/:id', this.requireAuth, async (req, res) => {\n            try {\n                const { name, description, category, cooldown, ownerOnly, isActive } = req.body;\n                \n                // Validation\n                if (!name || !description || !category) {\n                    return res.status(400).json({ error: 'Missing required fields' });\n                }\n                \n                // For now, simulate successful update\n                console.log(`Command ${req.params.id} updated:`, req.body);\n                \n                res.json({ \n                    success: true, \n                    message: 'Command updated successfully',\n                    command: {\n                        id: parseInt(req.params.id),\n                        name: name.toLowerCase().trim(),\n                        description,\n                        category,\n                        cooldown: cooldown || 3,\n                        ownerOnly: ownerOnly || false,\n                        isActive: isActive !== false\n                    }\n                });\n            } catch (error) {\n                console.error('Error updating command:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // Toggle command status\n        this.app.post('/api/commands/:id/toggle', this.requireAuth, async (req, res) => {\n            try {\n                const Command = require('../src/database/models/Command');\n                const { isActive } = req.body;\n\n                await Command.findByIdAndUpdate(req.params.id, { \n                    isActive,\n                    updatedAt: new Date()\n                });\n\n                res.json({ success: true, message: 'Command status updated' });\n            } catch (error) {\n                console.error('Error toggling command:', error);\n                // Simulate successful toggle for now\n                res.json({ \n                    success: true, \n                    message: `Command status toggled successfully`\n                });\n            }\n        });\n\n        // Update command\n        this.app.put('/api/commands/:id', this.requireAuth, async (req, res) => {\n            try {\n                const Command = require('../src/database/models/Command');\n                const { description, category, cooldown, ownerOnly } = req.body;\n                const updateData = {\n                    description,\n                    category,\n                    cooldown,\n                    ownerOnly,\n                    updatedAt: new Date()\n                };\n\n                await Command.findByIdAndUpdate(req.params.id, updateData);\n                res.json({ success: true, message: 'Command updated successfully' });\n            } catch (error) {\n                console.error('Error updating command:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // Initialize commands\n        this.app.post('/api/commands/initialize', this.requireAuth, async (req, res) => {\n            try {\n                const Command = require('../src/database/models/Command');\n                await Command.initializeCommands();\n                res.json({ success: true, message: 'Commands initialized successfully' });\n            } catch (error) {\n                console.error('Error initializing commands:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // API Routes for Menu Management\n\n        // Get all menu items\n        this.app.get('/api/menu', this.requireAuth, async (req, res) => {\n            try {\n                const Menu = require('../src/database/models/Menu'); // Assuming you have a Menu model\n                const menus = await Menu.find({});\n                res.json(menus);\n            } catch (error) {\n                console.error('Error getting menu items:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // Get single menu item\n        this.app.get('/api/menu/:id', this.requireAuth, async (req, res) => {\n            try {\n                const Menu = require('../src/database/models/Menu');\n                \n                // Handle special case for 'current'\n                if (req.params.id === 'current') {\n                    const menu = await Menu.findOne({ isActive: true });\n                    \n                    if (!menu) {\n                        return res.json({\n                            success: true,\n                            data: {\n                                title: 'Bot Menu',\n                                description: 'Welcome to our bot! Here are available features:',\n                                content: Menu.getDefaultContent(),\n                                isActive: true\n                            }\n                        });\n                    }\n\n                    return res.json({\n                        success: true,\n                        data: menu\n                    });\n                }\n                \n                const menu = await Menu.findById(req.params.id);\n                if (!menu) {\n                    return res.status(404).json({ error: 'Menu item not found' });\n                }\n                res.json(menu);\n            } catch (error) {\n                console.error('Error getting menu item:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // Create new menu item\n        this.app.post('/api/menu', this.requireAuth, async (req, res) => {\n            try {\n                const Menu = require('../src/database/models/Menu');\n                const { title, description, content } = req.body;\n                \n                if (!content || content.trim() === '') {\n                    return res.status(400).json({\n                        success: false,\n                        error: 'Menu content is required'\n                    });\n                }\n\n                // Find existing menu or create new one\n                let menu = await Menu.findOne({ isActive: true });\n                \n                if (menu) {\n                    // Update existing menu\n                    menu.title = title || menu.title;\n                    menu.description = description || menu.description;\n                    menu.content = content;\n                    menu.updatedAt = new Date();\n                    await menu.save();\n                } else {\n                    // Create new menu\n                    menu = new Menu({\n                        title: title || 'Bot Menu',\n                        description: description || 'Welcome to our bot! Here are available features:',\n                        content: content,\n                        isActive: true\n                    });\n                    await menu.save();\n                }\n                \n                res.json({\n                    success: true,\n                    message: 'Menu updated successfully',\n                    data: menu\n                });\n            } catch (error) {\n                console.error('Error creating/updating menu item:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // Get current menu for editing\n        this.app.get('/api/menu/current', this.requireAuth, async (req, res) => {\n            try {\n                const Menu = require('../src/database/models/Menu');\n                const menu = await Menu.findOne({ isActive: true });\n                \n                if (!menu) {\n                    return res.json({\n                        success: true,\n                        data: {\n                            title: 'Bot Menu',\n                            description: 'Welcome to our bot! Here are available features:',\n                            content: Menu.getDefaultContent(),\n                            isActive: true\n                        }\n                    });\n                }\n\n                res.json({\n                    success: true,\n                    data: menu\n                });\n            } catch (error) {\n                console.error('Error getting current menu:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // Reset menu to default\n        this.app.post('/api/menu/reset', this.requireAuth, async (req, res) => {\n            try {\n                const Menu = require('../src/database/models/Menu');\n                let menu = await Menu.findOne({ isActive: true });\n                \n                if (menu) {\n                    menu.title = 'Bot Menu';\n                    menu.description = 'Welcome to our bot! Here are available features:';\n                    menu.content = Menu.getDefaultContent();\n                    menu.updatedAt = new Date();\n                    await menu.save();\n                } else {\n                    menu = new Menu({\n                        title: 'Bot Menu',\n                        description: 'Welcome to our bot! Here are available features:',\n                        content: Menu.getDefaultContent(),\n                        isActive: true\n                    });\n                    await menu.save();\n                }\n                \n                res.json({\n                    success: true,\n                    message: 'Menu reset to default successfully',\n                    data: menu\n                });\n            } catch (error) {\n                console.error('Error resetting menu:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // Update menu item\n        this.app.put('/api/menu/:id', this.requireAuth, async (req, res) => {\n            try {\n                const Menu = require('../src/database/models/Menu');\n                await Menu.findByIdAndUpdate(req.params.id, req.body, { new: true });\n                res.json({ success: true, message: 'Menu item updated successfully' });\n            } catch (error) {\n                console.error('Error updating menu item:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // Delete menu item\n        this.app.delete('/api/menu/:id', this.requireAuth, async (req, res) => {\n            try {\n                const Menu = require('../src/database/models/Menu');\n                await Menu.findByIdAndDelete(req.params.id);\n                res.json({ success: true, message: 'Menu item deleted successfully' });\n            } catch (error) {\n                console.error('Error deleting menu item:', error);\n                res.status(500).json({ error: 'Internal server error' });\n            }\n        });\n\n        // Root redirect\n        this.app.get('/', (req, res) => {\n            if (req.session.isAuthenticated) {\n                res.redirect('/dashboard');\n            } else {\n                res.redirect('/auth/login');\n            }\n        });\n    }\n\n    requireAuth = (req, res, next) => {\n        if (!req.session.isAuthenticated) {\n            return res.redirect('/auth/login');\n        }\n        next();\n    };\n\n    start() {\n        try {\n            this.server = this.app.listen(this.port, '0.0.0.0', () => {\n                logger.info(`Simple Web dashboard running on http://0.0.0.0:${this.port}`);\n                console.log(`\\nðŸŒ Simple Web Dashboard: http://0.0.0.0:${this.port}`);\n                console.log(`ðŸ“Š Login with password: Faratama\\n`);\n            });\n\n            this.server.on('error', (error) => {\n                logger.error('Simple web server error:', error);\n            });\n\n        } catch (error) {\n            logger.error('Failed to start simple web server:', error);\n            throw error;\n        }\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close(() => {\n                logger.info('Simple web server stopped');\n            });\n        }\n    }\n}\n\nmodule.exports = SimpleWebServer;","size_bytes":23219},"src/client/whatsapp.js":{"content":"const { DisconnectReason, useMultiFileAuthState, makeWASocket, fetchLatestBaileysVersion, delay } = require('@whiskeysockets/baileys');\nconst qrcode = require('qrcode-terminal');\nconst fs = require('fs');\nconst path = require('path');\nconst config = require('../../config/config');\nconst logger = require('../utils/logger');\nconst MessageHandler = require('../handlers/messageHandler');\n\nclass WhatsAppClient {\n    constructor() {\n        this.socket = null;\n        this.authState = null;\n        this.messageHandler = new MessageHandler();\n        this.qrRetries = 0;\n        this.maxQrRetries = 3;\n    }\n\n    async initialize() {\n        try {\n            // Ensure sessions directory exists\n            const sessionsDir = path.resolve(config.whatsapp.sessionPath);\n            if (!fs.existsSync(sessionsDir)) {\n                fs.mkdirSync(sessionsDir, { recursive: true });\n                logger.info('Created sessions directory');\n            }\n\n            // Get latest Baileys version\n            const { version, isLatest } = await fetchLatestBaileysVersion();\n            logger.info(`Using Baileys version: ${version}, Latest: ${isLatest}`);\n\n            // Initialize auth state\n            const { state, saveCreds } = await useMultiFileAuthState(sessionsDir);\n            this.authState = state;\n\n            await this.createSocket(saveCreds);\n        } catch (error) {\n            logger.error('Failed to initialize WhatsApp client:', error);\n            throw error;\n        }\n    }\n\n    async createSocket(saveCreds) {\n        try {\n            this.socket = makeWASocket({\n                version: (await fetchLatestBaileysVersion()).version,\n                auth: this.authState,\n                printQRInTerminal: config.whatsapp.printQRInTerminal,\n                browser: config.whatsapp.browser,\n                defaultQueryTimeoutMs: config.whatsapp.authTimeout,\n                logger: require('pino')({ level: 'silent' }) // Suppress Baileys logs\n            });\n\n            this.bindEventHandlers(saveCreds);\n            logger.info('WhatsApp socket created successfully');\n        } catch (error) {\n            logger.error('Failed to create WhatsApp socket:', error);\n            throw error;\n        }\n    }\n\n    async requestPairingCode(phoneNumber) {\n        if (!this.socket) {\n            throw new Error('WhatsApp socket not initialized');\n        }\n        \n        try {\n            const code = await this.socket.requestPairingCode(phoneNumber);\n            logger.info(`Pairing code for ${phoneNumber}: ${code}`);\n            console.log(`\\n=== Pairing Code for WhatsApp ===`);\n            console.log(`Phone Number: ${phoneNumber}`);\n            console.log(`Pairing Code: ${code}`);\n            console.log(`Enter this code in WhatsApp > Linked Devices > Link a Device\\n`);\n            return code;\n        } catch (error) {\n            logger.error('Failed to request pairing code:', error);\n            throw error;\n        }\n    }\n\n    bindEventHandlers(saveCreds) {\n        // Connection update handler\n        this.socket.ev.on('connection.update', async (update) => {\n            const { connection, lastDisconnect, qr } = update;\n\n            if (qr) {\n                // Check if pairing mode is enabled\n                if (config.whatsapp.defaultConnectionMode === 'pairing' && config.whatsapp.pairingNumber) {\n                    logger.info('Pairing mode enabled, requesting pairing code...');\n                    try {\n                        await delay(2000); // Wait a bit for socket to be ready\n                        await this.requestPairingCode(config.whatsapp.pairingNumber);\n                    } catch (error) {\n                        logger.error('Failed to request pairing code, falling back to QR:', error.message);\n                        // Fall back to QR code\n                        if (config.whatsapp.printQRInTerminal) {\n                            console.log('\\n=== QR Code for WhatsApp Connection ===');\n                            qrcode.generate(qr, { small: true });\n                            console.log('Scan the QR code above with WhatsApp\\n');\n                        }\n                    }\n                } else if (config.whatsapp.printQRInTerminal) {\n                    console.log('\\n=== QR Code for WhatsApp Connection ===');\n                    qrcode.generate(qr, { small: true });\n                    console.log('Scan the QR code above with WhatsApp\\n');\n                }\n                \n                this.qrRetries++;\n                \n                if (this.qrRetries >= this.maxQrRetries) {\n                    logger.warn('Max QR retries reached, you may need to restart the bot');\n                }\n            }\n\n            if (connection === 'close') {\n                const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;\n                const errorCode = lastDisconnect?.error?.output?.statusCode;\n                \n                logger.info('Connection closed:', {\n                    shouldReconnect,\n                    errorCode,\n                    reason: this.getDisconnectReason(errorCode)\n                });\n\n                if (shouldReconnect) {\n                    logger.info('Attempting to reconnect...');\n                    setTimeout(() => this.createSocket(saveCreds), 5000);\n                } else {\n                    logger.info('Logged out from WhatsApp. Please restart the bot to login again.');\n                    process.exit(0);\n                }\n            } else if (connection === 'open') {\n                this.qrRetries = 0;\n                logger.info('Connected to WhatsApp successfully!');\n                \n                // Send initial message to owner\n                const ownerJid = config.bot.owner;\n                try {\n                    await this.socket.sendMessage(ownerJid, {\n                        text: `ðŸ¤– *${config.bot.name}* is now online!\\n\\nVersion: ${config.bot.version}\\nTime: ${new Date().toLocaleString()}`\n                    });\n                } catch (error) {\n                    logger.warn('Failed to send startup message to owner:', error.message);\n                }\n            }\n        });\n\n        // Credentials update handler\n        this.socket.ev.on('creds.update', saveCreds);\n\n        // Message handler\n        this.socket.ev.on('messages.upsert', async (m) => {\n            try {\n                await this.messageHandler.handleMessage(this.socket, m);\n            } catch (error) {\n                logger.error('Error handling message:', error);\n            }\n        });\n\n        // Group participants update\n        this.socket.ev.on('group-participants.update', (update) => {\n            logger.debug('Group participants update:', update);\n        });\n\n        // Presence update\n        this.socket.ev.on('presence.update', (update) => {\n            logger.debug('Presence update:', update);\n        });\n    }\n\n    getDisconnectReason(statusCode) {\n        const reasons = {\n            [DisconnectReason.badSession]: 'Bad Session File',\n            [DisconnectReason.connectionClosed]: 'Connection Closed',\n            [DisconnectReason.connectionLost]: 'Connection Lost',\n            [DisconnectReason.connectionReplaced]: 'Connection Replaced',\n            [DisconnectReason.loggedOut]: 'Logged Out',\n            [DisconnectReason.restartRequired]: 'Restart Required',\n            [DisconnectReason.timedOut]: 'Timed Out',\n            [DisconnectReason.multideviceMismatch]: 'Multi Device Mismatch'\n        };\n        \n        return reasons[statusCode] || 'Unknown Reason';\n    }\n\n    async sendMessage(jid, content) {\n        try {\n            if (!this.socket) {\n                throw new Error('WhatsApp socket not initialized');\n            }\n            \n            return await this.socket.sendMessage(jid, content);\n        } catch (error) {\n            logger.error('Failed to send message:', error);\n            throw error;\n        }\n    }\n\n    async getProfilePicture(jid) {\n        try {\n            return await this.socket.profilePictureUrl(jid, 'image');\n        } catch (error) {\n            logger.debug('Failed to get profile picture:', error.message);\n            return null;\n        }\n    }\n}\n\nmodule.exports = WhatsAppClient;\n","size_bytes":8312},"src/commands/menu.js":{"content":"\nconst config = require('../../config/config');\nconst Menu = require('../database/models/Menu');\n\nmodule.exports = {\n    name: 'menu',\n    description: 'Show bot menu with available commands and features',\n    usage: `${config.bot.prefixes[0]}menu`,\n    category: 'general',\n    cooldown: 3,\n    \n    async execute(context) {\n        const { reply } = context;\n        \n        try {\n            // Get menu content from database\n            const menuContent = await Menu.getMenuContent();\n            \n            await reply(menuContent);\n            \n        } catch (error) {\n            console.error('Error in menu command:', error);\n            \n            // Fallback to default menu if error occurs\n            const fallbackMenu = `ðŸ¤– *Bot Menu*\n\nðŸ“‹ *Available Commands:*\nâ€¢ .ping - Check bot status\nâ€¢ .menu - Show this menu\n\nâš™ï¸ *Bot Info:*\nâ€¢ Version: ${config.bot.version}\nâ€¢ Status: Online\n\nThank you for using our bot! ðŸ™`;\n            \n            await reply(fallbackMenu);\n        }\n    }\n};\n","size_bytes":1026},"src/commands/ping.js":{"content":"const config = require('../../config/config');\n\nmodule.exports = {\n    name: 'ping',\n    description: 'Check bot response time and status',\n    usage: `${config.bot.prefixes[0]}ping`,\n    category: 'utility',\n    \n    async execute(context) {\n        const { reply } = context;\n        const startTime = Date.now();\n        \n        try {\n            // Calculate response time\n            const responseTime = Date.now() - startTime;\n            \n            // Get system info\n            const uptime = process.uptime();\n            const memUsage = process.memoryUsage();\n            \n            const uptimeString = formatUptime(uptime);\n            const memUsageMB = (memUsage.rss / 1024 / 1024).toFixed(2);\n            \n            const response = `ðŸ“ *Pong!*\n\nâ±ï¸ *Response Time:* ${responseTime}ms\nðŸ”„ *Uptime:* ${uptimeString}\nðŸ’¾ *Memory Usage:* ${memUsageMB} MB\nðŸ¤– *Bot:* ${config.bot.name} v${config.bot.version}\nðŸ“… *Time:* ${new Date().toLocaleString()}\n\nâœ… Bot is running smoothly!`;\n            \n            await reply(response);\n            \n        } catch (error) {\n            await reply('âŒ Failed to get ping information');\n            throw error;\n        }\n    }\n};\n\nfunction formatUptime(seconds) {\n    const days = Math.floor(seconds / 86400);\n    const hours = Math.floor((seconds % 86400) / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n    \n    let result = '';\n    if (days > 0) result += `${days}d `;\n    if (hours > 0) result += `${hours}h `;\n    if (minutes > 0) result += `${minutes}m `;\n    result += `${secs}s`;\n    \n    return result;\n}\n","size_bytes":1651},"src/database/connection.js":{"content":"const { Sequelize } = require('sequelize');\nconst config = require('../../config/config');\nconst logger = require('../utils/logger');\n\nclass DatabaseConnection {\n    constructor() {\n        this.sequelize = null;\n        this.isConnected = false;\n        this.connectionRetries = 0;\n        this.maxRetries = 5;\n    }\n\n    async connect() {\n        try {\n            if (this.isConnected) {\n                logger.info('Already connected to PostgreSQL');\n                return;\n            }\n\n            logger.info('Connecting to PostgreSQL...');\n\n            this.sequelize = new Sequelize(config.database.uri, config.database.options);\n\n            // Test the connection\n            await this.sequelize.authenticate();\n\n            this.isConnected = true;\n            this.connectionRetries = 0;\n\n            logger.info(`Connected to PostgreSQL database: ${config.database.name}`);\n\n            // Initialize models\n            await this.initializeModels();\n\n            // Sync database (create tables if they don't exist)\n            await this.sequelize.sync();\n\n            // Initialize default data\n            await this.initializeDefaultData();\n\n        } catch (error) {\n            this.connectionRetries++;\n            logger.error(`Failed to connect to PostgreSQL (attempt ${this.connectionRetries}/${this.maxRetries}):`, error.message);\n\n            if (this.connectionRetries < this.maxRetries) {\n                const retryDelay = Math.min(1000 * Math.pow(2, this.connectionRetries), 30000);\n                logger.info(`Retrying connection in ${retryDelay}ms...`);\n\n                setTimeout(() => {\n                    this.connect();\n                }, retryDelay);\n            } else {\n                logger.error('Max connection retries reached. Exiting...');\n                process.exit(1);\n            }\n        }\n    }\n\n    async initializeModels() {\n        // Initialize all models with proper sequelize instance\n        const { initializeCommandModel } = require('./models/Command');\n        const { initializeUserModel } = require('./models/User');\n        const { initializeMenuModel } = require('./models/Menu');\n        const { initializeStatsModel } = require('./models/Stats');\n        const { initializeSessionModel } = require('./models/Session');\n\n        initializeCommandModel();\n        initializeUserModel();\n        initializeMenuModel();\n        initializeStatsModel();\n        initializeSessionModel();\n    }\n\n    async initializeDefaultData() {\n        try {\n            // Wait a bit for models to be fully initialized\n            await new Promise(resolve => setTimeout(resolve, 100));\n            \n            // Initialize default commands\n            const { Command } = require('./models/Command');\n            if (Command && typeof Command.initializeCommands === 'function') {\n                await Command.initializeCommands();\n            }\n\n            // Initialize default menu\n            const { Menu } = require('./models/Menu');\n            if (Menu && typeof Menu.initializeMenu === 'function') {\n                await Menu.initializeMenu();\n            }\n\n            logger.info('Default data initialized successfully');\n        } catch (error) {\n            logger.error('Error initializing default data:', error);\n        }\n    }\n\n    async disconnect() {\n        try {\n            if (this.sequelize) {\n                await this.sequelize.close();\n                logger.info('Disconnected from PostgreSQL');\n            }\n            this.isConnected = false;\n        } catch (error) {\n            logger.error('Error disconnecting from PostgreSQL:', error);\n        }\n    }\n\n    getConnectionStatus() {\n        return {\n            isConnected: this.isConnected,\n            database: config.database.name,\n            host: config.database.host,\n            port: config.database.port\n        };\n    }\n\n    getSequelize() {\n        return this.sequelize;\n    }\n}\n\nconst dbConnection = new DatabaseConnection();\n\nmodule.exports = {\n    connectToDatabase: () => dbConnection.connect(),\n    disconnectFromDatabase: () => dbConnection.disconnect(),\n    getConnectionStatus: () => dbConnection.getConnectionStatus()\n};","size_bytes":4195},"src/handlers/messageHandler.js":{"content":"const config = require('../../config/config');\nconst logger = require('../utils/logger');\nconst { isValidCommand, extractCommand, isOwner } = require('../utils/helpers');\nconst User = require('../database/models/User');\nconst Stats = require('../database/models/Stats');\nconst Command = require('../database/models/Command');\n\n// Import commands\nconst pingCommand = require('../commands/ping');\nconst menuCommand = require('../commands/menu');\n\nclass MessageHandler {\n    constructor() {\n        this.commands = new Map();\n        this.cooldowns = new Map();\n        this.rateLimits = new Map();\n\n        // Load commands asynchronously\n        this.loadCommands().catch(error => {\n            logger.error('Error in constructor loadCommands:', error);\n        });\n    }\n\n    async loadCommands() {\n        try {\n            // Load from database first\n            await this.loadCommandsFromDatabase();\n\n            // Register default file-based commands\n            this.commands.set('ping', pingCommand);\n            this.commands.set('menu', menuCommand);\n\n            logger.info(`Loaded ${this.commands.size} commands`);\n        } catch (error) {\n            logger.error('Error loading commands:', error);\n            // Fallback to file-based commands only\n            this.commands.set('ping', pingCommand);\n            this.commands.set('menu', menuCommand);\n        }\n    }\n\n    async loadCommandsFromDatabase() {\n        try {\n            const dbCommands = await Command.find({ isActive: true });\n\n            for (const cmd of dbCommands) {\n                // Check if we have a file-based handler for this command or its base name\n                const baseName = cmd.name.replace(/\\d+$/, ''); // Remove trailing numbers\n                const handler = this.getCommandHandler(cmd.name) || this.getCommandHandler(baseName);\n\n                if (handler) {\n                    // Update the command info from database\n                    const updatedHandler = {\n                        ...handler,\n                        name: cmd.name,\n                        description: cmd.description,\n                        usage: cmd.usage,\n                        cooldown: cmd.cooldown,\n                        category: cmd.category,\n                        ownerOnly: cmd.ownerOnly\n                    };\n\n                    this.commands.set(cmd.name, updatedHandler);\n                    logger.debug(`Loaded command from database: ${cmd.name} with usage: ${cmd.usage}`);\n                }\n            }\n        } catch (error) {\n            logger.error('Error loading commands from database:', error);\n        }\n    }\n\n    getCommandHandler(commandName) {\n        // Map of available command handlers\n        const handlers = {\n            'ping': pingCommand,\n            'menu': menuCommand\n        };\n\n        return handlers[commandName];\n    }\n\n    async reloadCommands() {\n        try {\n            // Clear existing commands\n            this.commands.clear();\n\n            // Reload from database and files\n            await this.loadCommands();\n\n            logger.info('Commands reloaded successfully');\n            return true;\n        } catch (error) {\n            logger.error('Error reloading commands:', error);\n            return false;\n        }\n    }\n\n    async checkAndReloadCommands() {\n        try {\n            // Check if database commands have been updated since last reload\n            const dbCommands = await Command.find({ isActive: true });\n            let needsReload = false;\n\n            // Check if any database command is different from loaded commands\n            for (const dbCmd of dbCommands) {\n                const loadedCmd = this.commands.get(dbCmd.name);\n                if (!loadedCmd ||\n                    loadedCmd.usage !== dbCmd.usage ||\n                    loadedCmd.cooldown !== dbCmd.cooldown ||\n                    loadedCmd.description !== dbCmd.description) {\n                    needsReload = true;\n                    break;\n                }\n            }\n\n            // Check if any loaded command is no longer in database or inactive\n            for (const [cmdName, _] of this.commands) {\n                if (cmdName !== 'ping') { // Don't check default commands\n                    const dbCmd = dbCommands.find(cmd => cmd.name === cmdName);\n                    if (!dbCmd || !dbCmd.isActive) {\n                        needsReload = true;\n                        break;\n                    }\n                }\n            }\n\n            if (needsReload) {\n                logger.info('Database commands changed, reloading...');\n                await this.reloadCommands();\n            }\n        } catch (error) {\n            logger.error('Error checking command updates:', error);\n        }\n    }\n\n    async handleMessage(socket, messageUpdate) {\n        try {\n            const messages = messageUpdate.messages;\n            if (!messages || !messages.length) return;\n\n            for (const message of messages) {\n                await this.processMessage(socket, message);\n            }\n        } catch (error) {\n            logger.error('Error in message handler:', error);\n        }\n    }\n\n    async processMessage(socket, message) {\n        try {\n            // Check if commands need to be reloaded (every 10th message)\n            if (Math.random() < 0.1) {\n                await this.checkAndReloadCommands();\n            }\n\n            // Skip if message is from status broadcast\n            if (message.key.remoteJid === 'status@broadcast') return;\n\n            // Skip if message is not from a user or group\n            if (!message.key.remoteJid) return;\n\n            // Skip if no message content\n            if (!message.message) return;\n\n            // Extract message text\n            const messageText = this.extractMessageText(message);\n            if (!messageText) return;\n\n            // Check if message starts with a prefix (e.g., '.')\n            if (!messageText.startsWith('.')) return;\n\n            // Extract command and arguments\n            const parts = messageText.slice(1).split(' ');\n            const command = parts[0].toLowerCase();\n            const args = parts.slice(1);\n\n            // Get user info\n            const sender = message.key.fromMe ? socket.user.id : message.key.participant || message.key.remoteJid;\n            const isGroup = message.key.remoteJid.endsWith('@g.us');\n\n            logger.info(`Command received: ${command} from ${sender} in ${isGroup ? 'group' : 'private'}`);\n\n            // Check rate limits\n            if (!this.checkRateLimit(sender)) {\n                logger.warn(`Rate limit exceeded for user: ${sender}`);\n                return;\n            }\n\n            // Check cooldown\n            const cooldownResult = await this.checkCooldown(sender, command);\n            if (!cooldownResult.allowed) {\n                logger.debug(`Cooldown active for user: ${sender}, command: ${command}`);\n\n                // Send cooldown message with remaining time\n                const remainingTime = Math.ceil(cooldownResult.remainingTime / 1000);\n                const cooldownMessage = `â³ Command masih dalam cooldown!\\nâ±ï¸ Tunggu ${remainingTime} detik lagi sebelum menggunakan command ini.`;\n\n                try {\n                    await socket.sendMessage(message.key.remoteJid, {\n                        text: cooldownMessage\n                    }, {\n                        quoted: message\n                    });\n                } catch (error) {\n                    logger.error('Failed to send cooldown message:', error);\n                }\n                return;\n            }\n\n            // Update user in database\n            await this.updateUser(sender, message);\n\n            // Execute command\n            await this.executeCommand(socket, message, command, args);\n\n            // Set cooldown\n            this.setCooldown(sender, command);\n\n        } catch (error) {\n            logger.error('Error processing message:', error);\n        }\n    }\n\n    extractMessageText(message) {\n        const messageTypes = [\n            'conversation',\n            'extendedTextMessage',\n            'imageMessage',\n            'videoMessage',\n            'documentMessage'\n        ];\n\n        for (const type of messageTypes) {\n            if (message.message[type]) {\n                if (type === 'conversation') {\n                    return message.message[type];\n                } else if (message.message[type].caption) {\n                    return message.message[type].caption;\n                } else if (message.message[type].text) {\n                    return message.message[type].text;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    async getCommandFromMessage(messageText) {\n        try {\n            // Get all active commands from database\n            const commands = await Command.find({ isActive: true });\n\n            for (const cmd of commands) {\n                // Check if message matches any command usage pattern\n                const usagePattern = cmd.usage.split(' ')[0]; // Get the command part only\n                if (messageText.toLowerCase().startsWith(usagePattern.toLowerCase())) {\n                    return cmd;\n                }\n            }\n\n            return null;\n        } catch (error) {\n            logger.error('Error getting command from message:', error);\n            return null;\n        }\n    }\n\n    extractArgsFromUsage(messageText, usage) {\n        const usagePattern = usage.split(' ')[0]; // Get command part like \".ping5\"\n\n        // Extract args (everything after the command)\n        const args = messageText.slice(usagePattern.length).trim().split(/\\s+/).filter(arg => arg.length > 0);\n\n        return args;\n    }\n\n    async executeCommand(socket, message, command, args) {\n        try {\n            // Check if command exists in database and is active\n            const commandDoc = await Command.findOne({ name: command });\n            if (!commandDoc || !commandDoc.isActive) {\n                logger.debug(`Command not found or inactive: ${command}`);\n                return;\n            }\n\n            // Try to find command handler - first try exact match, then try base name\n            let commandHandler = this.commands.get(command);\n\n            if (!commandHandler) {\n                // Try to find handler by base name (remove numbers/suffixes)\n                const baseName = command.replace(/\\d+$/, ''); // Remove trailing numbers\n                commandHandler = this.commands.get(baseName);\n            }\n\n            if (!commandHandler) {\n                logger.debug(`Unknown command handler: ${command}, tried base name: ${command.replace(/\\d+$/, '')}`);\n                return;\n            }\n            const context = {\n                socket,\n                message,\n                args,\n                sender: message.key.fromMe ? socket.user.id : message.key.participant || message.key.remoteJid,\n                chat: message.key.remoteJid,\n                isGroup: message.key.remoteJid.endsWith('@g.us'),\n                isOwner: isOwner(message.key.fromMe ? socket.user.id : message.key.participant || message.key.remoteJid),\n                reply: async (text) => {\n                    await socket.sendMessage(message.key.remoteJid, {\n                        text: text\n                    }, {\n                        quoted: message\n                    });\n                }\n            };\n\n            // Execute command with timeout\n            const timeout = new Promise((_, reject) =>\n                setTimeout(() => reject(new Error('Command timeout')), config.commands.timeout)\n            );\n\n            await Promise.race([\n                commandHandler.execute(context),\n                timeout\n            ]);\n\n            // Increment command counter in database\n            await Stats.incrementCommandCount();\n            await Command.incrementUsage(command);\n            logger.info(`Command executed: ${command} by ${context.sender}`);\n\n        } catch (error) {\n            logger.error(`Error executing command ${command}:`, error);\n\n            // Send error message to user\n            try {\n                await socket.sendMessage(message.key.remoteJid, {\n                    text: `âŒ An error occurred while executing the command: ${command}`\n                }, {\n                    quoted: message\n                });\n            } catch (sendError) {\n                logger.error('Failed to send error message:', sendError);\n            }\n        }\n    }\n\n    checkRateLimit(userId) {\n        const now = Date.now();\n        const userLimits = this.rateLimits.get(userId) || { requests: [], banned: 0 };\n\n        // Check if user is banned\n        if (userLimits.banned && now < userLimits.banned) {\n            return false;\n        }\n\n        // Remove old requests\n        userLimits.requests = userLimits.requests.filter(time => now - time < 60000);\n\n        // Check rate limits\n        if (userLimits.requests.length >= config.rateLimit.maxRequestsPerMinute) {\n            userLimits.banned = now + config.rateLimit.banDuration;\n            this.rateLimits.set(userId, userLimits);\n            return false;\n        }\n\n        // Add current request\n        userLimits.requests.push(now);\n        userLimits.banned = 0;\n        this.rateLimits.set(userId, userLimits);\n\n        return true;\n    }\n\n    async checkCooldown(userId, command) {\n        try {\n            const now = Date.now();\n            const userCooldowns = this.cooldowns.get(userId) || {};\n            const lastUsed = userCooldowns[command] || 0;\n\n            // Get cooldown from database (in seconds), convert to milliseconds\n            const commandDoc = await Command.findOne({ name: command });\n            const cooldownMs = commandDoc ? (commandDoc.cooldown * 1000) : (config.commands.cooldown || 2000);\n\n            const timePassed = now - lastUsed;\n            const isAllowed = timePassed >= cooldownMs;\n            const remainingTime = isAllowed ? 0 : cooldownMs - timePassed;\n\n            return {\n                allowed: isAllowed,\n                remainingTime: remainingTime\n            };\n        } catch (error) {\n            logger.error('Error checking cooldown:', error);\n            // Fallback to config cooldown\n            const now = Date.now();\n            const userCooldowns = this.cooldowns.get(userId) || {};\n            const lastUsed = userCooldowns[command] || 0;\n            const timePassed = now - lastUsed;\n            const cooldownMs = config.commands.cooldown || 2000;\n            const isAllowed = timePassed >= cooldownMs;\n            const remainingTime = isAllowed ? 0 : cooldownMs - timePassed;\n\n            return {\n                allowed: isAllowed,\n                remainingTime: remainingTime\n            };\n        }\n    }\n\n    setCooldown(userId, command) {\n        const now = Date.now();\n        const userCooldowns = this.cooldowns.get(userId) || {};\n        userCooldowns[command] = now;\n        this.cooldowns.set(userId, userCooldowns);\n    }\n\n    async updateUser(userId, message) {\n        try {\n            const userData = {\n                jid: userId,\n                lastSeen: new Date()\n            };\n\n            // Extract additional user info if available\n            if (message.pushName) {\n                userData.name = message.pushName;\n            }\n\n            await User.findOneAndUpdate(\n                { jid: userId },\n                { $set: userData, $inc: { messageCount: 1 } },\n                { upsert: true, new: true }\n            );\n\n        } catch (error) {\n            logger.error('Failed to update user:', error);\n        }\n    }\n}\n\nmodule.exports = MessageHandler;","size_bytes":15756},"src/utils/helpers.js":{"content":"const config = require('../../config/config');\n\n/**\n * Check if a message starts with a valid command prefix\n * @param {string} text - The message text\n * @returns {boolean} - True if the message starts with a valid prefix\n */\nfunction isValidCommand(text) {\n    if (!text || typeof text !== 'string') return false;\n    \n    return config.bot.prefixes.some(prefix => text.trim().startsWith(prefix));\n}\n\n/**\n * Extract command and arguments from message text\n * @param {string} text - The message text\n * @returns {Object} - Object containing command and args\n */\nfunction extractCommand(text) {\n    if (!text || typeof text !== 'string') {\n        return { command: null, args: [] };\n    }\n\n    const trimmedText = text.trim();\n    let usedPrefix = null;\n    \n    // Find which prefix was used\n    for (const prefix of config.bot.prefixes) {\n        if (trimmedText.startsWith(prefix)) {\n            usedPrefix = prefix;\n            break;\n        }\n    }\n    \n    if (!usedPrefix) {\n        return { command: null, args: [] };\n    }\n    \n    // Remove prefix and split into parts\n    const withoutPrefix = trimmedText.slice(usedPrefix.length);\n    const parts = withoutPrefix.trim().split(/\\s+/);\n    \n    if (parts.length === 0 || !parts[0]) {\n        return { command: null, args: [] };\n    }\n    \n    const command = parts[0].toLowerCase();\n    const args = parts.slice(1);\n    \n    return { command, args, prefix: usedPrefix };\n}\n\n/**\n * Check if a user is the bot owner\n * @param {string} jid - User JID\n * @returns {boolean} - True if user is owner\n */\nfunction isOwner(jid) {\n    if (!jid) return false;\n    \n    // Clean the JID to handle different formats\n    const cleanJid = jid.replace('@s.whatsapp.net', '').replace('@c.us', '');\n    const ownerNumber = config.bot.owner.replace('@s.whatsapp.net', '').replace('@c.us', '');\n    \n    return cleanJid === ownerNumber;\n}\n\n/**\n * Format phone number to WhatsApp JID format\n * @param {string} phone - Phone number\n * @returns {string} - Formatted JID\n */\nfunction formatPhoneNumber(phone) {\n    if (!phone) return null;\n    \n    // Remove all non-numeric characters\n    let cleaned = phone.replace(/\\D/g, '');\n    \n    // Remove leading zeros\n    cleaned = cleaned.replace(/^0+/, '');\n    \n    // Add country code if not present\n    if (!cleaned.startsWith('62') && cleaned.length <= 12) {\n        cleaned = '62' + cleaned;\n    }\n    \n    return cleaned + '@s.whatsapp.net';\n}\n\n/**\n * Extract phone number from JID\n * @param {string} jid - WhatsApp JID\n * @returns {string} - Phone number\n */\nfunction extractPhoneNumber(jid) {\n    if (!jid) return null;\n    \n    return jid.replace('@s.whatsapp.net', '').replace('@c.us', '');\n}\n\n/**\n * Check if JID is a group\n * @param {string} jid - WhatsApp JID\n * @returns {boolean} - True if it's a group\n */\nfunction isGroup(jid) {\n    return jid && jid.endsWith('@g.us');\n}\n\n/**\n * Format uptime in human readable format\n * @param {number} seconds - Uptime in seconds\n * @returns {string} - Formatted uptime\n */\nfunction formatUptime(seconds) {\n    const days = Math.floor(seconds / 86400);\n    const hours = Math.floor((seconds % 86400) / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n    \n    let result = '';\n    if (days > 0) result += `${days}d `;\n    if (hours > 0) result += `${hours}h `;\n    if (minutes > 0) result += `${minutes}m `;\n    result += `${secs}s`;\n    \n    return result;\n}\n\n/**\n * Format bytes in human readable format\n * @param {number} bytes - Size in bytes\n * @returns {string} - Formatted size\n */\nfunction formatBytes(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n\n/**\n * Sleep for specified milliseconds\n * @param {number} ms - Milliseconds to sleep\n * @returns {Promise} - Promise that resolves after sleep\n */\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate random string\n * @param {number} length - Length of string\n * @returns {string} - Random string\n */\nfunction generateRandomString(length = 8) {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    \n    for (let i = 0; i < length; i++) {\n        result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    \n    return result;\n}\n\n/**\n * Escape text for WhatsApp markdown\n * @param {string} text - Text to escape\n * @returns {string} - Escaped text\n */\nfunction escapeMarkdown(text) {\n    if (!text || typeof text !== 'string') return '';\n    \n    return text\n        .replace(/\\*/g, '\\\\*')\n        .replace(/_/g, '\\\\_')\n        .replace(/~/g, '\\\\~')\n        .replace(/`/g, '\\\\`');\n}\n\n/**\n * Create WhatsApp mention format\n * @param {string} jid - User JID to mention\n * @param {string} name - Display name\n * @returns {Object} - WhatsApp mention object\n */\nfunction createMention(jid, name = null) {\n    const cleanJid = jid.includes('@') ? jid : jid + '@s.whatsapp.net';\n    const displayName = name || extractPhoneNumber(cleanJid);\n    \n    return {\n        text: `@${displayName}`,\n        jid: cleanJid\n    };\n}\n\n/**\n * Validate phone number format\n * @param {string} phone - Phone number to validate\n * @returns {boolean} - True if valid\n */\nfunction isValidPhoneNumber(phone) {\n    if (!phone || typeof phone !== 'string') return false;\n    \n    const cleaned = phone.replace(/\\D/g, '');\n    return cleaned.length >= 10 && cleaned.length <= 15;\n}\n\n/**\n * Get current timestamp in ISO format\n * @returns {string} - ISO timestamp\n */\nfunction getCurrentTimestamp() {\n    return new Date().toISOString();\n}\n\n/**\n * Parse duration string to milliseconds\n * @param {string} duration - Duration string (e.g., '1d', '2h', '30m', '45s')\n * @returns {number} - Duration in milliseconds\n */\nfunction parseDuration(duration) {\n    if (!duration || typeof duration !== 'string') return 0;\n    \n    const units = {\n        's': 1000,\n        'm': 60 * 1000,\n        'h': 60 * 60 * 1000,\n        'd': 24 * 60 * 60 * 1000,\n        'w': 7 * 24 * 60 * 60 * 1000\n    };\n    \n    const match = duration.match(/^(\\d+)([smhdw])$/);\n    if (!match) return 0;\n    \n    const [, amount, unit] = match;\n    return parseInt(amount) * (units[unit] || 0);\n}\n\nmodule.exports = {\n    isValidCommand,\n    extractCommand,\n    isOwner,\n    formatPhoneNumber,\n    extractPhoneNumber,\n    isGroup,\n    formatUptime,\n    formatBytes,\n    sleep,\n    generateRandomString,\n    escapeMarkdown,\n    createMention,\n    isValidPhoneNumber,\n    getCurrentTimestamp,\n    parseDuration\n};\n","size_bytes":6741},"src/utils/logger.js":{"content":"const winston = require('winston');\nconst path = require('path');\nconst fs = require('fs');\nconst config = require('../../config/config');\n\n// Ensure logs directory exists\nconst logsDir = path.dirname(config.logging.file.filename);\nif (!fs.existsSync(logsDir)) {\n    fs.mkdirSync(logsDir, { recursive: true });\n}\n\n// Custom format for console output\nconst consoleFormat = winston.format.combine(\n    winston.format.colorize(),\n    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),\n    winston.format.errors({ stack: true }),\n    winston.format.printf(({ timestamp, level, message, ...meta }) => {\n        let msg = `${timestamp} [${level}]: ${message}`;\n        \n        if (Object.keys(meta).length > 0) {\n            msg += '\\n' + JSON.stringify(meta, null, 2);\n        }\n        \n        return msg;\n    })\n);\n\n// Custom format for file output\nconst fileFormat = winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n);\n\n// Create transports array\nconst transports = [];\n\n// Console transport\nif (config.logging.console.enabled) {\n    transports.push(new winston.transports.Console({\n        level: config.logging.level,\n        format: consoleFormat,\n        handleExceptions: true,\n        handleRejections: true\n    }));\n}\n\n// File transport\nif (config.logging.file.enabled) {\n    transports.push(new winston.transports.File({\n        level: config.logging.level,\n        filename: config.logging.file.filename,\n        format: fileFormat,\n        maxsize: config.logging.file.maxSize,\n        maxFiles: config.logging.file.maxFiles,\n        handleExceptions: true,\n        handleRejections: true\n    }));\n}\n\n// Create logger instance\nconst logger = winston.createLogger({\n    level: config.logging.level,\n    transports,\n    exitOnError: false\n});\n\n// Add custom methods\nlogger.command = (command, user, args = []) => {\n    logger.info(`Command executed: ${command}`, {\n        type: 'command',\n        command,\n        user,\n        args,\n        timestamp: new Date().toISOString()\n    });\n};\n\nlogger.database = (operation, collection, data = {}) => {\n    logger.debug(`Database operation: ${operation}`, {\n        type: 'database',\n        operation,\n        collection,\n        data,\n        timestamp: new Date().toISOString()\n    });\n};\n\nlogger.whatsapp = (event, data = {}) => {\n    logger.info(`WhatsApp event: ${event}`, {\n        type: 'whatsapp',\n        event,\n        data,\n        timestamp: new Date().toISOString()\n    });\n};\n\nlogger.security = (event, user, data = {}) => {\n    logger.warn(`Security event: ${event}`, {\n        type: 'security',\n        event,\n        user,\n        data,\n        timestamp: new Date().toISOString()\n    });\n};\n\nlogger.performance = (operation, duration, data = {}) => {\n    logger.info(`Performance: ${operation} took ${duration}ms`, {\n        type: 'performance',\n        operation,\n        duration,\n        data,\n        timestamp: new Date().toISOString()\n    });\n};\n\n// Handle uncaught exceptions and rejections\nprocess.on('unhandledRejection', (reason, promise) => {\n    logger.error('Unhandled Rejection at:', promise, 'reason:', reason);\n});\n\nprocess.on('uncaughtException', (error) => {\n    logger.error('Uncaught Exception:', error);\n    process.exit(1);\n});\n\nmodule.exports = logger;\n","size_bytes":3336},"web/routes/auth.js":{"content":"const express = require('express');\nconst bcrypt = require('bcrypt');\nconst rateLimit = require('express-rate-limit');\nconst logger = require('../../src/utils/logger');\n\nconst router = express.Router();\n\n// Rate limiting for login attempts\nconst loginLimiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 5, // limit each IP to 5 login attempts per windowMs\n    message: 'Too many login attempts, please try again later.',\n    skipSuccessfulRequests: true\n});\n\n// Login page\nrouter.get('/login', (req, res) => {\n    if (req.session.isAuthenticated) {\n        return res.redirect('/dashboard');\n    }\n    \n    res.render('auth/login', {\n        title: 'SeaBot Dashboard - Login',\n        error: req.query.error\n    });\n});\n\n// Login handler\nrouter.post('/login', loginLimiter, async (req, res) => {\n    try {\n        const { password } = req.body;\n        \n        if (!password) {\n            return res.redirect('/auth/login?error=Password is required');\n        }\n\n        // Check password (hardcoded for now, could be moved to config later)\n        const correctPassword = 'Faratama';\n        \n        if (password === correctPassword) {\n            req.session.isAuthenticated = true;\n            req.session.loginTime = new Date();\n            \n            logger.info('Successful login from IP:', req.ip);\n            \n            res.redirect('/dashboard');\n        } else {\n            logger.warn('Failed login attempt from IP:', req.ip);\n            res.redirect('/auth/login?error=Invalid password');\n        }\n        \n    } catch (error) {\n        logger.error('Login error:', error);\n        res.redirect('/auth/login?error=An error occurred');\n    }\n});\n\n// Logout handler\nrouter.post('/logout', (req, res) => {\n    req.session.destroy((err) => {\n        if (err) {\n            logger.error('Logout error:', err);\n            return res.redirect('/dashboard');\n        }\n        \n        res.redirect('/auth/login');\n    });\n});\n\n// Logout GET route for convenience\nrouter.get('/logout', (req, res) => {\n    req.session.destroy((err) => {\n        if (err) {\n            logger.error('Logout error:', err);\n            return res.redirect('/dashboard');\n        }\n        \n        res.redirect('/auth/login');\n    });\n});\n\nmodule.exports = router;","size_bytes":2283},"web/routes/command.js":{"content":"const express = require('express');\nconst fs = require('fs').promises;\nconst path = require('path');\nconst logger = require('../../src/utils/logger');\nconst Command = require('../../src/database/models/Command');\n\nconst router = express.Router();\n\n// Get all commands\nasync function getAllCommands() {\n    try {\n        const commandsPath = path.join(__dirname, '../../src/commands');\n        const files = await fs.readdir(commandsPath);\n        const commands = [];\n\n        for (const file of files) {\n            if (file.endsWith('.js')) {\n                try {\n                    const commandPath = path.join(commandsPath, file);\n                    const command = require(commandPath);\n                    commands.push({\n                        file: file,\n                        name: command.name || 'Unknown',\n                        description: command.description || 'No description',\n                        usage: command.usage || 'No usage info',\n                        category: command.category || 'General',\n                        cooldown: command.cooldown || 0\n                    });\n                } catch (error) {\n                    logger.error(`Error loading command ${file}:`, error);\n                    commands.push({\n                        file: file,\n                        name: file.replace('.js', ''),\n                        description: 'Error loading command',\n                        usage: 'N/A',\n                        category: 'Error',\n                        cooldown: 0,\n                        error: true\n                    });\n                }\n            }\n        }\n\n        return commands;\n    } catch (error) {\n        logger.error('Error getting commands:', error);\n        return [];\n    }\n}\n\n// Commands page\nrouter.get('/', async (req, res) => {\n    try {\n        const commands = await getAllCommands();\n        \n        res.render('dashboard/commands', {\n            title: 'Command Management - SeaBot Dashboard',\n            commands\n        });\n    } catch (error) {\n        logger.error('Commands page error:', error);\n        res.status(500).render('error', {\n            title: 'Commands Error',\n            error: {\n                status: 500,\n                message: 'Unable to load commands'\n            }\n        });\n    }\n});\n\n// API endpoint to get command details\nrouter.get('/api/command/:name', async (req, res) => {\n    try {\n        const commandName = req.params.name;\n        const commandPath = path.join(__dirname, '../../src/commands', `${commandName}.js`);\n        \n        // Check if command file exists\n        try {\n            await fs.access(commandPath);\n        } catch {\n            return res.status(404).json({\n                success: false,\n                error: 'Command not found'\n            });\n        }\n\n        const command = require(commandPath);\n        const fileContent = await fs.readFile(commandPath, 'utf-8');\n\n        res.json({\n            success: true,\n            data: {\n                ...command,\n                fileContent,\n                filePath: commandPath\n            }\n        });\n    } catch (error) {\n        logger.error('Command API error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to fetch command data'\n        });\n    }\n});\n\n// API endpoint to update command\nrouter.post('/api/command/:name', async (req, res) => {\n    try {\n        const commandName = req.params.name;\n        const { fileContent } = req.body;\n        \n        if (!fileContent) {\n            return res.status(400).json({\n                success: false,\n                error: 'File content is required'\n            });\n        }\n\n        const commandPath = path.join(__dirname, '../../src/commands', `${commandName}.js`);\n        \n        // Backup original file\n        const backupPath = path.join(__dirname, '../../src/commands', `${commandName}.js.backup`);\n        try {\n            const originalContent = await fs.readFile(commandPath, 'utf-8');\n            await fs.writeFile(backupPath, originalContent);\n        } catch (error) {\n            logger.warn('Could not create backup:', error);\n        }\n\n        // Write new content\n        await fs.writeFile(commandPath, fileContent);\n        \n        // Clear require cache to reload the module\n        delete require.cache[require.resolve(commandPath)];\n        \n        logger.info(`Command ${commandName} updated by admin`);\n        res.json({\n            success: true,\n            message: 'Command updated successfully'\n        });\n    } catch (error) {\n        logger.error('Update command error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to update command'\n        });\n    }\n});\n\n// API endpoint to create new command\nrouter.post('/api/command', async (req, res) => {\n    try {\n        const { name, fileContent } = req.body;\n        \n        if (!name || !fileContent) {\n            return res.status(400).json({\n                success: false,\n                error: 'Name and file content are required'\n            });\n        }\n\n        const commandPath = path.join(__dirname, '../../src/commands', `${name}.js`);\n        \n        // Check if command already exists\n        try {\n            await fs.access(commandPath);\n            return res.status(400).json({\n                success: false,\n                error: 'Command already exists'\n            });\n        } catch {\n            // File doesn't exist, which is what we want\n        }\n\n        await fs.writeFile(commandPath, fileContent);\n        \n        logger.info(`New command ${name} created by admin`);\n        res.json({\n            success: true,\n            message: 'Command created successfully'\n        });\n    } catch (error) {\n        logger.error('Create command error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to create command'\n        });\n    }\n});\n\n// API endpoint to delete command\nrouter.delete('/api/command/:name', async (req, res) => {\n    try {\n        const commandName = req.params.name;\n        const commandPath = path.join(__dirname, '../../src/commands', `${commandName}.js`);\n        \n        // Check if command exists\n        try {\n            await fs.access(commandPath);\n        } catch {\n            return res.status(404).json({\n                success: false,\n                error: 'Command not found'\n            });\n        }\n\n        // Create backup before deleting\n        const backupPath = path.join(__dirname, '../../src/commands', `${commandName}.js.deleted`);\n        const fileContent = await fs.readFile(commandPath, 'utf-8');\n        await fs.writeFile(backupPath, fileContent);\n        \n        // Delete the command\n        await fs.unlink(commandPath);\n        \n        // Clear require cache\n        delete require.cache[require.resolve(commandPath)];\n        \n        logger.info(`Command ${commandName} deleted by admin`);\n        res.json({\n            success: true,\n            message: 'Command deleted successfully'\n        });\n    } catch (error) {\n        logger.error('Delete command error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to delete command'\n        });\n    }\n});\n\n// API endpoint to get database commands\nrouter.get('/api/database/commands', async (req, res) => {\n    try {\n        const commands = await Command.find({}).sort({ name: 1 });\n        res.json({\n            success: true,\n            data: commands\n        });\n    } catch (error) {\n        logger.error('Database commands API error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to fetch database commands'\n        });\n    }\n});\n\n// API endpoint to update database command\nrouter.put('/api/database/command/:id', async (req, res) => {\n    try {\n        const commandId = req.params.id;\n        const updateData = req.body;\n        \n        const command = await Command.findByIdAndUpdate(\n            commandId,\n            {\n                ...updateData,\n                updatedAt: new Date()\n            },\n            { new: true, runValidators: true }\n        );\n        \n        if (!command) {\n            return res.status(404).json({\n                success: false,\n                error: 'Command not found'\n            });\n        }\n        \n        // Notify that commands should be reloaded\n        // In a production environment, you might want to emit an event here\n        logger.info(`Database command ${command.name} updated by admin`);\n        \n        res.json({\n            success: true,\n            message: 'Command updated successfully',\n            data: command\n        });\n    } catch (error) {\n        logger.error('Update database command error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to update command'\n        });\n    }\n});\n\n// API endpoint to create database command\nrouter.post('/api/database/command', async (req, res) => {\n    try {\n        const commandData = req.body;\n        \n        const command = new Command({\n            ...commandData,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        });\n        \n        await command.save();\n        \n        logger.info(`New database command ${command.name} created by admin`);\n        res.json({\n            success: true,\n            message: 'Command created successfully',\n            data: command\n        });\n    } catch (error) {\n        logger.error('Create database command error:', error);\n        res.status(500).json({\n            success: false,\n            error: error.message || 'Unable to create command'\n        });\n    }\n});\n\n// API endpoint to reload commands (notify bot to reload)\nrouter.post('/api/commands/reload', async (req, res) => {\n    try {\n        // Set a flag that the bot can check periodically\n        // For now, just log the request\n        logger.info('Commands reload requested by admin');\n        \n        res.json({\n            success: true,\n            message: 'Command reload request sent. Bot will reload commands on next message processing.'\n        });\n    } catch (error) {\n        logger.error('Reload commands error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to process reload request'\n        });\n    }\n});\n\nmodule.exports = router;","size_bytes":10475},"web/routes/config.js":{"content":"const express = require('express');\nconst fs = require('fs').promises;\nconst path = require('path');\nconst logger = require('../../src/utils/logger');\nconst config = require('../../config/config');\n\nconst router = express.Router();\n\n// Config page\nrouter.get('/', async (req, res) => {\n    try {\n        res.render('dashboard/config', {\n            title: 'Configuration - SeaBot Dashboard',\n            config: {\n                bot: config.bot,\n                whatsapp: config.whatsapp,\n                database: {\n                    name: config.database.name,\n                    // Hide sensitive connection string details\n                    connected: true\n                },\n                logging: config.logging\n            }\n        });\n    } catch (error) {\n        logger.error('Config page error:', error);\n        res.status(500).render('error', {\n            title: 'Config Error',\n            error: {\n                status: 500,\n                message: 'Unable to load configuration'\n            }\n        });\n    }\n});\n\n// API endpoint to get current config\nrouter.get('/api/config', (req, res) => {\n    try {\n        res.json({\n            success: true,\n            data: {\n                bot: config.bot,\n                whatsapp: {\n                    ...config.whatsapp,\n                    // Hide sensitive data\n                    sessionPath: '[HIDDEN]'\n                },\n                database: {\n                    name: config.database.name\n                },\n                logging: config.logging\n            }\n        });\n    } catch (error) {\n        logger.error('Config API error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to fetch configuration'\n        });\n    }\n});\n\n// API endpoint to update bot config\nrouter.post('/api/config/bot', async (req, res) => {\n    try {\n        const { name, version, prefixes, ownerNumber } = req.body;\n        \n        const configPath = path.join(__dirname, '../../config/config.js');\n        const configContent = await fs.readFile(configPath, 'utf-8');\n        \n        let updatedConfig = configContent;\n        \n        if (name) {\n            updatedConfig = updatedConfig.replace(\n                /name:\\s*['\"](.*?)['\"],/,\n                `name: '${name}',`\n            );\n        }\n        \n        if (version) {\n            updatedConfig = updatedConfig.replace(\n                /version:\\s*['\"](.*?)['\"],/,\n                `version: '${version}',`\n            );\n        }\n        \n        if (prefixes && Array.isArray(prefixes)) {\n            updatedConfig = updatedConfig.replace(\n                /prefixes:\\s*\\[(.*?)\\],/s,\n                `prefixes: ${JSON.stringify(prefixes)},`\n            );\n        }\n        \n        if (ownerNumber) {\n            updatedConfig = updatedConfig.replace(\n                /ownerNumber:\\s*['\"](.*?)['\"],/,\n                `ownerNumber: '${ownerNumber}',`\n            );\n        }\n        \n        await fs.writeFile(configPath, updatedConfig);\n        \n        // Clear require cache to reload config\n        delete require.cache[require.resolve('../../config/config')];\n        \n        logger.info('Bot configuration updated by admin');\n        res.json({\n            success: true,\n            message: 'Bot configuration updated successfully'\n        });\n    } catch (error) {\n        logger.error('Update bot config error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to update bot configuration'\n        });\n    }\n});\n\n// API endpoint to update logging config\nrouter.post('/api/config/logging', async (req, res) => {\n    try {\n        const { level, enableFileLog, enableConsoleLog } = req.body;\n        \n        const configPath = path.join(__dirname, '../../config/config.js');\n        const configContent = await fs.readFile(configPath, 'utf-8');\n        \n        let updatedConfig = configContent;\n        \n        if (level) {\n            updatedConfig = updatedConfig.replace(\n                /level:\\s*['\"](.*?)['\"],/,\n                `level: '${level}',`\n            );\n        }\n        \n        if (enableFileLog !== undefined) {\n            updatedConfig = updatedConfig.replace(\n                /enableFileLog:\\s*(true|false),/,\n                `enableFileLog: ${enableFileLog},`\n            );\n        }\n        \n        if (enableConsoleLog !== undefined) {\n            updatedConfig = updatedConfig.replace(\n                /enableConsoleLog:\\s*(true|false),/,\n                `enableConsoleLog: ${enableConsoleLog},`\n            );\n        }\n        \n        await fs.writeFile(configPath, updatedConfig);\n        \n        // Clear require cache to reload config\n        delete require.cache[require.resolve('../../config/config')];\n        \n        logger.info('Logging configuration updated by admin');\n        res.json({\n            success: true,\n            message: 'Logging configuration updated successfully'\n        });\n    } catch (error) {\n        logger.error('Update logging config error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to update logging configuration'\n        });\n    }\n});\n\n// API endpoint to restart bot (if needed)\nrouter.post('/api/restart', (req, res) => {\n    try {\n        logger.info('Bot restart requested by admin');\n        \n        // In a production environment, you might want to use PM2 or similar\n        // For now, just log the request\n        res.json({\n            success: true,\n            message: 'Restart request logged. Please manually restart the bot if needed.'\n        });\n    } catch (error) {\n        logger.error('Restart request error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to process restart request'\n        });\n    }\n});\n\n// API endpoint to get logs\nrouter.get('/api/logs', async (req, res) => {\n    try {\n        const logsPath = path.join(__dirname, '../../logs/seabot.log');\n        const lines = parseInt(req.query.lines) || 100;\n        \n        try {\n            const logContent = await fs.readFile(logsPath, 'utf-8');\n            const logLines = logContent.split('\\n').slice(-lines);\n            \n            res.json({\n                success: true,\n                data: {\n                    lines: logLines.filter(line => line.trim()),\n                    totalLines: logLines.length\n                }\n            });\n        } catch (error) {\n            res.json({\n                success: true,\n                data: {\n                    lines: ['Log file not found or empty'],\n                    totalLines: 0\n                }\n            });\n        }\n    } catch (error) {\n        logger.error('Get logs error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to fetch logs'\n        });\n    }\n});\n\nmodule.exports = router;","size_bytes":6924},"web/routes/dashboard.js":{"content":"const express = require('express');\nconst User = require('../../src/database/models/User');\nconst logger = require('../../src/utils/logger');\n\nconst router = express.Router();\n\n// Get bot statistics\nasync function getBotStats() {\n    try {\n        const totalUsers = await User.countDocuments();\n        const totalCommands = await User.aggregate([\n            { $group: { _id: null, total: { $sum: \"$messageCount\" } } }\n        ]);\n        \n        const activeUsers = await User.countDocuments({\n            lastSeen: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } // Last 24 hours\n        });\n\n        return {\n            totalUsers,\n            totalCommands: totalCommands[0]?.total || 0,\n            activeUsers,\n            uptime: process.uptime(),\n            memoryUsage: process.memoryUsage(),\n            nodeVersion: process.version\n        };\n    } catch (error) {\n        logger.error('Error getting bot stats:', error);\n        return {\n            totalUsers: 0,\n            totalCommands: 0,\n            activeUsers: 0,\n            uptime: process.uptime(),\n            memoryUsage: process.memoryUsage(),\n            nodeVersion: process.version\n        };\n    }\n}\n\n// Format uptime to human readable\nfunction formatUptime(seconds) {\n    const days = Math.floor(seconds / (24 * 60 * 60));\n    const hours = Math.floor((seconds % (24 * 60 * 60)) / (60 * 60));\n    const minutes = Math.floor((seconds % (60 * 60)) / 60);\n    const secs = Math.floor(seconds % 60);\n    \n    return `${days}d ${hours}h ${minutes}m ${secs}s`;\n}\n\n// Format memory usage\nfunction formatMemory(bytes) {\n    const mb = bytes / 1024 / 1024;\n    return `${mb.toFixed(2)} MB`;\n}\n\n// Dashboard home\nrouter.get('/', async (req, res) => {\n    try {\n        const stats = await getBotStats();\n        \n        res.render('dashboard/index', {\n            title: 'SeaBot Dashboard',\n            stats: {\n                ...stats,\n                uptimeFormatted: formatUptime(stats.uptime),\n                memoryFormatted: {\n                    rss: formatMemory(stats.memoryUsage.rss),\n                    heapTotal: formatMemory(stats.memoryUsage.heapTotal),\n                    heapUsed: formatMemory(stats.memoryUsage.heapUsed),\n                    external: formatMemory(stats.memoryUsage.external)\n                }\n            },\n            user: {\n                loginTime: req.session.loginTime\n            }\n        });\n    } catch (error) {\n        logger.error('Dashboard error:', error);\n        res.status(500).render('error', {\n            title: 'Dashboard Error',\n            error: {\n                status: 500,\n                message: 'Unable to load dashboard data'\n            }\n        });\n    }\n});\n\n// API endpoint for real-time stats\nrouter.get('/api/stats', async (req, res) => {\n    try {\n        const stats = await getBotStats();\n        res.json({\n            success: true,\n            data: {\n                ...stats,\n                uptimeFormatted: formatUptime(stats.uptime),\n                timestamp: new Date().toISOString()\n            }\n        });\n    } catch (error) {\n        logger.error('Stats API error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to fetch stats'\n        });\n    }\n});\n\nmodule.exports = router;","size_bytes":3306},"web/routes/data.js":{"content":"const express = require('express');\nconst User = require('../../src/database/models/User');\nconst logger = require('../../src/utils/logger');\n\nconst router = express.Router();\n\n// Data page - show users and statistics\nrouter.get('/', async (req, res) => {\n    try {\n        const page = parseInt(req.query.page) || 1;\n        const limit = parseInt(req.query.limit) || 20;\n        const skip = (page - 1) * limit;\n\n        // Get users with pagination\n        const users = await User.find({})\n            .sort({ lastSeen: -1 })\n            .skip(skip)\n            .limit(limit);\n\n        const totalUsers = await User.countDocuments();\n        const totalPages = Math.ceil(totalUsers / limit);\n\n        res.render('dashboard/data', {\n            title: 'Data Management - SeaBot Dashboard',\n            users,\n            pagination: {\n                currentPage: page,\n                totalPages,\n                totalUsers,\n                hasNext: page < totalPages,\n                hasPrev: page > 1,\n                limit\n            }\n        });\n    } catch (error) {\n        logger.error('Data page error:', error);\n        res.status(500).render('error', {\n            title: 'Data Error',\n            error: {\n                status: 500,\n                message: 'Unable to load user data'\n            }\n        });\n    }\n});\n\n// API endpoint to get user details  \nrouter.get('/api/user/:jid', async (req, res) => {\n    try {\n        const user = await User.findOne({ jid: req.params.jid });\n        if (!user) {\n            return res.status(404).json({\n                success: false,\n                error: 'User not found'\n            });\n        }\n\n        res.json({\n            success: true,\n            data: user\n        });\n    } catch (error) {\n        logger.error('User API error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to fetch user data'\n        });\n    }\n});\n\n// API endpoint to update user\nrouter.post('/api/user/:jid', async (req, res) => {\n    try {\n        const { name, isBanned, isOwner } = req.body;\n        \n        const updateData = {};\n        if (name !== undefined) updateData.name = name;\n        if (isBanned !== undefined) updateData.isBanned = isBanned;\n        if (isOwner !== undefined) updateData.isOwner = isOwner;\n\n        const user = await User.findOneAndUpdate(\n            { jid: req.params.jid },\n            { $set: updateData },\n            { new: true }\n        );\n\n        if (!user) {\n            return res.status(404).json({\n                success: false,\n                error: 'User not found'\n            });\n        }\n\n        logger.info(`User ${req.params.jid} updated by admin`);\n        res.json({\n            success: true,\n            data: user,\n            message: 'User updated successfully'\n        });\n    } catch (error) {\n        logger.error('Update user error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to update user'\n        });\n    }\n});\n\n// API endpoint to delete user\nrouter.delete('/api/user/:jid', async (req, res) => {\n    try {\n        const user = await User.findOneAndDelete({ jid: req.params.jid });\n        \n        if (!user) {\n            return res.status(404).json({\n                success: false,\n                error: 'User not found'\n            });\n        }\n\n        logger.info(`User ${req.params.jid} deleted by admin`);\n        res.json({\n            success: true,\n            message: 'User deleted successfully'\n        });\n    } catch (error) {\n        logger.error('Delete user error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to delete user'\n        });\n    }\n});\n\n// Export users data\nrouter.get('/export', async (req, res) => {\n    try {\n        const users = await User.find({}).select('-_id -__v');\n        \n        res.setHeader('Content-Type', 'application/json');\n        res.setHeader('Content-Disposition', 'attachment; filename=seabot-users.json');\n        res.json(users);\n    } catch (error) {\n        logger.error('Export error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to export data'\n        });\n    }\n});\n\nmodule.exports = router;","size_bytes":4285},"web/routes/menu.js":{"content":"\nconst express = require('express');\nconst logger = require('../../src/utils/logger');\nconst Menu = require('../../src/database/models/Menu');\n\nconst router = express.Router();\n\n// Menu management page\nrouter.get('/', async (req, res) => {\n    try {\n        const menu = await Menu.findOne({ isActive: true }) || {\n            title: 'Bot Menu',\n            description: 'Welcome to our bot! Here are available features:',\n            content: Menu.getDefaultContent()\n        };\n        \n        res.render('dashboard/menu', {\n            title: 'Menu Management - SeaBot Dashboard',\n            menu\n        });\n    } catch (error) {\n        logger.error('Menu page error:', error);\n        res.status(500).render('error', {\n            title: 'Menu Error',\n            error: {\n                status: 500,\n                message: 'Unable to load menu settings'\n            }\n        });\n    }\n});\n\n// API endpoint to get current menu\nrouter.get('/api/menu', async (req, res) => {\n    try {\n        const menu = await Menu.findOne({ isActive: true });\n        \n        if (!menu) {\n            return res.json({\n                success: true,\n                data: {\n                    title: 'Bot Menu',\n                    description: 'Welcome to our bot! Here are available features:',\n                    content: Menu.getDefaultContent(),\n                    isActive: true\n                }\n            });\n        }\n\n        res.json({\n            success: true,\n            data: menu\n        });\n    } catch (error) {\n        logger.error('Get menu API error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to fetch menu data'\n        });\n    }\n});\n\n// API endpoint to update menu\nrouter.post('/api/menu', async (req, res) => {\n    try {\n        const { title, description, content } = req.body;\n        \n        if (!content || content.trim() === '') {\n            return res.status(400).json({\n                success: false,\n                error: 'Menu content is required'\n            });\n        }\n\n        // Find existing menu or create new one\n        let menu = await Menu.findOne({ isActive: true });\n        \n        if (menu) {\n            // Update existing menu\n            menu.title = title || menu.title;\n            menu.description = description || menu.description;\n            menu.content = content;\n            menu.updatedAt = new Date();\n            await menu.save();\n        } else {\n            // Create new menu\n            menu = new Menu({\n                title: title || 'Bot Menu',\n                description: description || 'Welcome to our bot! Here are available features:',\n                content: content,\n                isActive: true\n            });\n            await menu.save();\n        }\n        \n        logger.info('Menu updated by admin');\n        res.json({\n            success: true,\n            message: 'Menu updated successfully',\n            data: menu\n        });\n    } catch (error) {\n        logger.error('Update menu error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to update menu'\n        });\n    }\n});\n\n// API endpoint to reset menu to default\nrouter.post('/api/menu/reset', async (req, res) => {\n    try {\n        let menu = await Menu.findOne({ isActive: true });\n        \n        if (menu) {\n            menu.title = 'Bot Menu';\n            menu.description = 'Welcome to our bot! Here are available features:';\n            menu.content = Menu.getDefaultContent();\n            menu.updatedAt = new Date();\n            await menu.save();\n        } else {\n            menu = new Menu({\n                title: 'Bot Menu',\n                description: 'Welcome to our bot! Here are available features:',\n                content: Menu.getDefaultContent(),\n                isActive: true\n            });\n            await menu.save();\n        }\n        \n        logger.info('Menu reset to default by admin');\n        res.json({\n            success: true,\n            message: 'Menu reset to default successfully',\n            data: menu\n        });\n    } catch (error) {\n        logger.error('Reset menu error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Unable to reset menu'\n        });\n    }\n});\n\nmodule.exports = router;\n","size_bytes":4347},"src/database/models/Command.js":{"content":"const { DataTypes, Model } = require('sequelize');\nconst { getSequelize } = require('../connection');\n\nclass Command extends Model {\n    // Static method to get total active commands\n    static async getTotalActiveCommands() {\n        try {\n            const count = await this.count({ where: { isActive: true } });\n            return count;\n        } catch (error) {\n            console.error('Error getting total active commands:', error);\n            return 0;\n        }\n    }\n\n    // Static method to increment command usage\n    static async incrementUsage(commandName) {\n        try {\n            await this.increment('usageCount', {\n                where: { name: commandName }\n            });\n        } catch (error) {\n            console.error('Error incrementing command usage:', error);\n        }\n    }\n\n    // Static method to initialize default commands\n    static async initializeCommands() {\n        try {\n            const commands = [\n                {\n                    name: 'ping',\n                    description: 'Check bot response time and status',\n                    category: 'utility',\n                    cooldown: 2,\n                    ownerOnly: false,\n                    isActive: true\n                },\n                {\n                    name: 'menu',\n                    description: 'Show bot menu with available commands and features',\n                    category: 'general',\n                    cooldown: 3,\n                    ownerOnly: false,\n                    isActive: true\n                }\n            ];\n\n            for (const cmd of commands) {\n                await this.findOrCreate({\n                    where: { name: cmd.name },\n                    defaults: cmd\n                });\n            }\n            \n            console.log('Commands initialized successfully');\n        } catch (error) {\n            console.error('Error initializing commands:', error);\n        }\n    }\n}\n\n// Get sequelize instance from connection\nconst dbConnection = require('../connection');\nlet sequelize;\n\n// Initialize the model only when sequelize is available\nconst initializeCommandModel = () => {\n    const connection = require('../connection');\n    if (!sequelize && connection.getSequelize) {\n        sequelize = connection.getSequelize();\n    }\n\n    if (sequelize) {\n        Command.init({\n            id: {\n                type: DataTypes.INTEGER,\n                primaryKey: true,\n                autoIncrement: true\n            },\n            name: {\n                type: DataTypes.STRING,\n                allowNull: false,\n                unique: true,\n                set(value) {\n                    this.setDataValue('name', value ? value.toLowerCase().trim() : value);\n                }\n            },\n            description: {\n                type: DataTypes.TEXT,\n                allowNull: false\n            },\n            category: {\n                type: DataTypes.ENUM('general', 'utility', 'fun', 'admin', 'owner'),\n                defaultValue: 'general'\n            },\n            isActive: {\n                type: DataTypes.BOOLEAN,\n                defaultValue: true\n            },\n            cooldown: {\n                type: DataTypes.INTEGER,\n                defaultValue: 2 // in seconds\n            },\n            ownerOnly: {\n                type: DataTypes.BOOLEAN,\n                defaultValue: false\n            },\n            usageCount: {\n                type: DataTypes.INTEGER,\n                defaultValue: 0\n            }\n        }, {\n            sequelize,\n            modelName: 'Command',\n            tableName: 'commands',\n            timestamps: true\n        });\n    }\n};\n\n// Try to initialize immediately if sequelize is available\ntry {\n    initializeCommandModel();\n} catch (error) {\n    // Will be initialized later when connection is established\n}\n\nmodule.exports = { Command, initializeCommandModel };","size_bytes":3900},"src/database/models/Menu.js":{"content":"\nconst { DataTypes, Model } = require('sequelize');\n\nclass Menu extends Model {\n    // Static method to get menu content\n    static async getMenuContent() {\n        try {\n            const menu = await this.findOne({ where: { isActive: true } });\n            return menu ? menu.content : this.getDefaultContent();\n        } catch (error) {\n            console.error('Error getting menu content:', error);\n            return this.getDefaultContent();\n        }\n    }\n\n    // Static method for default content\n    static getDefaultContent() {\n        return `ðŸ¤– *Bot Menu*\n\nðŸ“‹ *Available Commands:*\nâ€¢ .ping - Check bot status\nâ€¢ .menu - Show this menu\n\nâš™ï¸ *Bot Info:*\nâ€¢ Version: 1.0.0\nâ€¢ Status: Online\n\nThank you for using our bot! ðŸ™`;\n    }\n\n    // Static method to initialize default menu\n    static async initializeMenu() {\n        try {\n            const existingMenu = await this.findOne();\n            if (!existingMenu) {\n                await this.create({\n                    title: 'Bot Menu',\n                    description: 'Welcome to our bot! Here are available features:',\n                    content: this.getDefaultContent()\n                });\n                console.log('Default menu initialized successfully');\n            }\n        } catch (error) {\n            console.error('Error initializing menu:', error);\n        }\n    }\n}\n\n// Get sequelize instance from connection\nconst dbConnection = require('../connection');\nlet sequelize;\n\n// Initialize the model only when sequelize is available\nconst initializeMenuModel = () => {\n    const connection = require('../connection');\n    if (!sequelize && connection.getSequelize) {\n        sequelize = connection.getSequelize();\n    }\n\n    if (sequelize) {\n        Menu.init({\n            id: {\n                type: DataTypes.INTEGER,\n                primaryKey: true,\n                autoIncrement: true\n            },\n            title: {\n                type: DataTypes.STRING,\n                allowNull: false,\n                defaultValue: 'Bot Menu'\n            },\n            description: {\n                type: DataTypes.TEXT,\n                defaultValue: 'Welcome to our bot! Here are available features:'\n            },\n            content: {\n                type: DataTypes.TEXT,\n                allowNull: false,\n                defaultValue: Menu.getDefaultContent()\n            },\n            isActive: {\n                type: DataTypes.BOOLEAN,\n                defaultValue: true\n            }\n        }, {\n            sequelize,\n            modelName: 'Menu',\n            tableName: 'menus',\n            timestamps: true\n        });\n    }\n};\n\n// Try to initialize immediately if sequelize is available\ntry {\n    initializeMenuModel();\n} catch (error) {\n    // Will be initialized later when connection is established\n}\n\nmodule.exports = { Menu, initializeMenuModel };\n","size_bytes":2871},"src/database/models/Session.js":{"content":"const { DataTypes, Model, Op } = require('sequelize');\n\nclass Session extends Model {\n    // Instance methods\n    async updateLastConnected() {\n        const connectionInfo = this.connectionInfo || {};\n        connectionInfo.lastConnected = new Date();\n        connectionInfo.connectionCount = (connectionInfo.connectionCount || 0) + 1;\n        this.connectionInfo = connectionInfo;\n        this.isActive = true;\n        return this.save();\n    }\n\n    async deactivate() {\n        this.isActive = false;\n        return this.save();\n    }\n\n    async extendExpiry(days = 30) {\n        this.expiresAt = new Date(Date.now() + days * 24 * 60 * 60 * 1000);\n        return this.save();\n    }\n\n    async addUptime(uptimeMs) {\n        const connectionInfo = this.connectionInfo || {};\n        connectionInfo.totalUptime = (connectionInfo.totalUptime || 0) + uptimeMs;\n        this.connectionInfo = connectionInfo;\n        return this.save();\n    }\n\n    // Static methods\n    static findByJid(jid) {\n        return this.findOne({ where: { jid, isActive: true } });\n    }\n\n    static findActiveSession(sessionId) {\n        return this.findOne({ where: { sessionId, isActive: true } });\n    }\n\n    static deactivateExpiredSessions() {\n        return this.update(\n            { isActive: false },\n            { where: { expiresAt: { [Op.lte]: new Date() } } }\n        );\n    }\n\n    static cleanupOldSessions(days = 60) {\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - days);\n        \n        return this.destroy({\n            where: {\n                [Op.or]: [\n                    { isActive: false, updatedAt: { [Op.lte]: cutoffDate } },\n                    { expiresAt: { [Op.lte]: cutoffDate } }\n                ]\n            }\n        });\n    }\n\n    static async getSessionStats() {\n        try {\n            const result = await this.findAll({\n                attributes: [\n                    [this.sequelize.fn('COUNT', '*'), 'totalSessions'],\n                    [this.sequelize.fn('COUNT', this.sequelize.literal('CASE WHEN \"isActive\" = true THEN 1 END')), 'activeSessions'],\n                    [this.sequelize.fn('AVG', this.sequelize.literal('\"connectionInfo\"::jsonb->\\'totalUptime\\'')), 'averageUptime'],\n                    [this.sequelize.fn('SUM', this.sequelize.literal('\"connectionInfo\"::jsonb->\\'connectionCount\\'')), 'totalConnections']\n                ],\n                raw: true\n            });\n            return result[0];\n        } catch (error) {\n            console.error('Error getting session stats:', error);\n            return { totalSessions: 0, activeSessions: 0, averageUptime: 0, totalConnections: 0 };\n        }\n    }\n}\n\n// Get sequelize instance from connection\nconst dbConnection = require('../connection');\nlet sequelize;\n\n// Initialize the model only when sequelize is available\nconst initializeSessionModel = () => {\n    const connection = require('../connection');\n    if (!sequelize && connection.getSequelize) {\n        sequelize = connection.getSequelize();\n    }\n\n    if (sequelize) {\n        Session.init({\n            id: {\n                type: DataTypes.INTEGER,\n                primaryKey: true,\n                autoIncrement: true\n            },\n            sessionId: {\n                type: DataTypes.STRING,\n                allowNull: false,\n                unique: true\n            },\n            jid: {\n                type: DataTypes.STRING,\n                allowNull: false\n            },\n            sessionData: {\n                type: DataTypes.JSONB,\n                allowNull: false\n            },\n            deviceInfo: {\n                type: DataTypes.JSONB,\n                defaultValue: {}\n            },\n            connectionInfo: {\n                type: DataTypes.JSONB,\n                defaultValue: {\n                    lastConnected: new Date(),\n                    connectionCount: 1,\n                    totalUptime: 0\n                }\n            },\n            isActive: {\n                type: DataTypes.BOOLEAN,\n                defaultValue: true\n            },\n            expiresAt: {\n                type: DataTypes.DATE,\n                defaultValue: () => new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days\n            }\n        }, {\n            sequelize,\n            modelName: 'Session',\n            tableName: 'sessions',\n            timestamps: true,\n            indexes: [\n                { fields: ['sessionId'] },\n                { fields: ['jid'] },\n                { fields: ['isActive'] },\n                { fields: ['expiresAt'] }\n            ]\n        });\n    }\n};\n\n// Try to initialize immediately if sequelize is available\ntry {\n    initializeSessionModel();\n} catch (error) {\n    // Will be initialized later when connection is established\n}\n\nmodule.exports = { Session, initializeSessionModel };\n","size_bytes":4841},"src/database/models/Stats.js":{"content":"const { DataTypes, Model, Op } = require('sequelize');\n\nclass Stats extends Model {\n    // Static method to increment command counter\n    static async incrementCommandCount() {\n        try {\n            const [stat, created] = await this.findOrCreate({\n                where: { type: 'totalCommands' },\n                defaults: { type: 'totalCommands', count: 0, lastUpdated: new Date() }\n            });\n            \n            if (!created) {\n                await stat.increment('count');\n                stat.lastUpdated = new Date();\n                await stat.save();\n            } else {\n                await stat.increment('count');\n            }\n            \n            await stat.reload();\n            return stat.count;\n        } catch (error) {\n            console.error('Error incrementing command count:', error);\n            return null;\n        }\n    }\n\n    // Static method to get command count\n    static async getCommandCount() {\n        try {\n            const stat = await this.findOne({ where: { type: 'totalCommands' } });\n            return stat ? stat.count : 0;\n        } catch (error) {\n            console.error('Error getting command count:', error);\n            return 0;\n        }\n    }\n}\n\n// Get sequelize instance from connection\nconst dbConnection = require('../connection');\nlet sequelize;\n\n// Initialize the model only when sequelize is available\nconst initializeStatsModel = () => {\n    const connection = require('../connection');\n    if (!sequelize && connection.getSequelize) {\n        sequelize = connection.getSequelize();\n    }\n\n    if (sequelize) {\n        Stats.init({\n            id: {\n                type: DataTypes.INTEGER,\n                primaryKey: true,\n                autoIncrement: true\n            },\n            type: {\n                type: DataTypes.STRING,\n                allowNull: false,\n                unique: true\n            },\n            count: {\n                type: DataTypes.INTEGER,\n                defaultValue: 0\n            },\n            lastUpdated: {\n                type: DataTypes.DATE,\n                defaultValue: DataTypes.NOW\n            }\n        }, {\n            sequelize,\n            modelName: 'Stats',\n            tableName: 'stats',\n            timestamps: true\n        });\n    }\n};\n\n// Try to initialize immediately if sequelize is available\ntry {\n    initializeStatsModel();\n} catch (error) {\n    // Will be initialized later when connection is established\n}\n\nmodule.exports = { Stats, initializeStatsModel };","size_bytes":2510},"src/database/models/User.js":{"content":"const { DataTypes, Model, Op } = require('sequelize');\n\nclass User extends Model {\n    // Instance methods\n    async ban(reason, duration) {\n        this.isBanned = true;\n        this.banReason = reason;\n        if (duration) {\n            this.banExpiry = new Date(Date.now() + duration);\n        }\n        return this.save();\n    }\n\n    async unban() {\n        this.isBanned = false;\n        this.banReason = null;\n        this.banExpiry = null;\n        return this.save();\n    }\n\n    isCurrentlyBanned() {\n        if (!this.isBanned) return false;\n        if (!this.banExpiry) return true;\n        return Date.now() < this.banExpiry.getTime();\n    }\n\n    async incrementMessageCount() {\n        this.messageCount += 1;\n        const stats = this.stats || {};\n        stats.totalMessages = (stats.totalMessages || 0) + 1;\n        this.stats = stats;\n        this.lastSeen = new Date();\n        return this.save();\n    }\n\n    async incrementCommandCount(command) {\n        this.commandCount += 1;\n        const stats = this.stats || {};\n        stats.totalCommands = (stats.totalCommands || 0) + 1;\n        \n        // Update favorite commands\n        const favoriteCommands = stats.favoriteCommands || [];\n        const favCommand = favoriteCommands.find(f => f.command === command);\n        if (favCommand) {\n            favCommand.count += 1;\n        } else {\n            favoriteCommands.push({ command, count: 1 });\n        }\n        \n        // Keep only top 10 favorite commands\n        favoriteCommands.sort((a, b) => b.count - a.count);\n        stats.favoriteCommands = favoriteCommands.slice(0, 10);\n        \n        this.stats = stats;\n        this.lastSeen = new Date();\n        return this.save();\n    }\n\n    // Static methods\n    static findByJid(jid) {\n        return this.findOne({ where: { jid } });\n    }\n\n    static findOwners() {\n        return this.findAll({ where: { isOwner: true } });\n    }\n\n    static findBanned() {\n        return this.findAll({ where: { isBanned: true } });\n    }\n\n    static getActiveUsers(days = 7) {\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - days);\n        \n        return this.findAll({\n            where: {\n                lastSeen: {\n                    [Op.gte]: cutoffDate\n                }\n            },\n            order: [['lastSeen', 'DESC']]\n        });\n    }\n\n    static async getUserStats() {\n        try {\n            const result = await this.findAll({\n                attributes: [\n                    [this.sequelize.fn('COUNT', '*'), 'totalUsers'],\n                    [this.sequelize.fn('SUM', this.sequelize.col('messageCount')), 'totalMessages'],\n                    [this.sequelize.fn('SUM', this.sequelize.col('commandCount')), 'totalCommands'],\n                    [this.sequelize.fn('COUNT', this.sequelize.literal('CASE WHEN \"isBanned\" = true THEN 1 END')), 'bannedUsers']\n                ],\n                raw: true\n            });\n            return result[0];\n        } catch (error) {\n            console.error('Error getting user stats:', error);\n            return { totalUsers: 0, totalMessages: 0, totalCommands: 0, bannedUsers: 0 };\n        }\n    }\n}\n\n// Get sequelize instance from connection\nconst dbConnection = require('../connection');\nlet sequelize;\n\n// Initialize the model only when sequelize is available\nconst initializeUserModel = () => {\n    const connection = require('../connection');\n    if (!sequelize && connection.getSequelize) {\n        sequelize = connection.getSequelize();\n    }\n\n    if (sequelize) {\n        User.init({\n            id: {\n                type: DataTypes.INTEGER,\n                primaryKey: true,\n                autoIncrement: true\n            },\n            jid: {\n                type: DataTypes.STRING,\n                allowNull: false,\n                unique: true\n            },\n            name: {\n                type: DataTypes.STRING,\n                allowNull: true\n            },\n            phoneNumber: {\n                type: DataTypes.STRING,\n                allowNull: true\n            },\n            isOwner: {\n                type: DataTypes.BOOLEAN,\n                defaultValue: false\n            },\n            isBanned: {\n                type: DataTypes.BOOLEAN,\n                defaultValue: false\n            },\n            banReason: {\n                type: DataTypes.TEXT,\n                allowNull: true\n            },\n            banExpiry: {\n                type: DataTypes.DATE,\n                allowNull: true\n            },\n            messageCount: {\n                type: DataTypes.INTEGER,\n                defaultValue: 0\n            },\n            commandCount: {\n                type: DataTypes.INTEGER,\n                defaultValue: 0\n            },\n            lastSeen: {\n                type: DataTypes.DATE,\n                defaultValue: DataTypes.NOW\n            },\n            firstSeen: {\n                type: DataTypes.DATE,\n                defaultValue: DataTypes.NOW\n            },\n            settings: {\n                type: DataTypes.JSONB,\n                defaultValue: {\n                    language: 'en',\n                    notifications: true\n                }\n            },\n            stats: {\n                type: DataTypes.JSONB,\n                defaultValue: {\n                    totalCommands: 0,\n                    totalMessages: 0,\n                    favoriteCommands: []\n                }\n            }\n        }, {\n            sequelize,\n            modelName: 'User',\n            tableName: 'users',\n            timestamps: true,\n            indexes: [\n                { fields: ['jid'] },\n                { fields: ['isOwner'] },\n                { fields: ['isBanned'] },\n                { fields: ['lastSeen'] }\n            ]\n        });\n    }\n};\n\n// Try to initialize immediately if sequelize is available\ntry {\n    initializeUserModel();\n} catch (error) {\n    // Will be initialized later when connection is established\n}\n\nmodule.exports = { User, initializeUserModel };\n","size_bytes":6021}}}